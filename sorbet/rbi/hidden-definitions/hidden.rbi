# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class ActionNetwork
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ActionNetworkEvent
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ActionNetworkRequest
  include ::HTTParty::ModuleInheritableAttributes
end

class ActionNetworkRequest
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.default_cookies(); end

  def self.default_cookies=(default_cookies); end

  def self.default_options=(default_options); end
end

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(obj); end
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def clean(backtrace, kind=T.unsafe(nil)); end

  def remove_filters!(); end

  def remove_silencers!(); end
end

class ActiveSupport::BacktraceCleaner
end

module ActiveSupport::Benchmarkable
  def benchmark(message=T.unsafe(nil), options=T.unsafe(nil)); end

  def silence(); end
end

module ActiveSupport::Benchmarkable
end

class ActiveSupport::BufferedLogger
  include ::ActiveSupport::BufferedLogger::Severity
  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def auto_flushing(*args, &block); end

  def auto_flushing=(*args, &block); end

  def auto_flushing_with_deprecation(*args, &block); end

  def auto_flushing_with_deprecation=(*args, &block); end

  def auto_flushing_without_deprecation(); end

  def auto_flushing_without_deprecation=(period); end

  def close(); end

  def debug(message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def flush(*args, &block); end

  def flush_with_deprecation(*args, &block); end

  def flush_without_deprecation(); end

  def info(message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(log, level=T.unsafe(nil)); end

  def level(); end

  def level=(l); end

  def open_log(*args, &block); end

  def open_log_with_deprecation(*args, &block); end

  def open_log_without_deprecation(log, mode); end

  def respond_to?(method, include_private=T.unsafe(nil)); end

  def silence(*args, &block); end

  def silence_with_deprecation(*args, &block); end

  def silence_without_deprecation(temporary_level=T.unsafe(nil)); end

  def silencer(); end

  def silencer=(obj); end

  def unknown(message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def unknown?(); end

  def warn(message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def warn?(); end
  MAX_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::BufferedLogger::Severity
  DEBUG = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FATAL = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  WARN = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::BufferedLogger::Severity
end

class ActiveSupport::BufferedLogger
  def self.silencer(); end

  def self.silencer=(obj); end
end

module ActiveSupport::Cache
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
  def compressed?(); end

  def created_at(); end

  def expired?(); end

  def expires_at(); end

  def expires_at=(time); end

  def expires_in(); end

  def initialize(value, options=T.unsafe(nil)); end

  def raw_value(); end

  def size(); end

  def value(); end
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
  def self.create(raw_value, created_at, options=T.unsafe(nil)); end
end

class ActiveSupport::Cache::FileStore
  def cache_path(); end

  def initialize(cache_path, options=T.unsafe(nil)); end
  DIR_FORMATTER = ::T.let(nil, ::T.untyped)
  EXCLUDED_DIRS = ::T.let(nil, ::T.untyped)
  FILENAME_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::FileStore
end

class ActiveSupport::Cache::MemoryStore
  def prune(target_size, max_time=T.unsafe(nil)); end

  def pruning?(); end

  def synchronize(&block); end
end

class ActiveSupport::Cache::MemoryStore
end

class ActiveSupport::Cache::NullStore
end

class ActiveSupport::Cache::NullStore
end

class ActiveSupport::Cache::Store
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(name, options=T.unsafe(nil)); end

  def delete_entry(key, options); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def exist?(name, options=T.unsafe(nil)); end

  def fetch(name, options=T.unsafe(nil)); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def key_matcher(pattern, options); end

  def logger(); end

  def logger=(obj); end

  def mute(); end

  def options(); end

  def read(name, options=T.unsafe(nil)); end

  def read_entry(key, options); end

  def read_multi(*names); end

  def silence(); end

  def silence!(); end

  def silence?(); end

  def write(name, value, options=T.unsafe(nil)); end

  def write_entry(key, entry, options); end
end

class ActiveSupport::Cache::Store
  def self.instrument(); end

  def self.instrument=(boolean); end

  def self.logger(); end

  def self.logger=(obj); end
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache::Strategy::LocalCache
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_entry(key, options); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def middleware(); end

  def read_entry(key, options); end

  def with_local_cache(); end

  def write_entry(key, entry, options); end
end

class ActiveSupport::Cache::Strategy::LocalCache::LocalStore
  def initialize(); end

  def synchronize(); end

  def write_entry(key, value, options); end
end

class ActiveSupport::Cache::Strategy::LocalCache::LocalStore
end

class ActiveSupport::Cache::Strategy::LocalCache::Middleware
  def call(env); end

  def initialize(name, thread_local_key); end

  def name(); end

  def new(app); end

  def thread_local_key(); end
end

class ActiveSupport::Cache::Strategy::LocalCache::Middleware
end

module ActiveSupport::Cache::Strategy::LocalCache
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache
  def self.expand_cache_key(key, namespace=T.unsafe(nil)); end

  def self.lookup_store(*store_option); end
end

module ActiveSupport::Callbacks
  def run_callbacks(kind, *args, &block); end
end

class ActiveSupport::Callbacks::Callback
  def _compile_per_key_options(); end

  def _update_filter(filter_options, new_options); end

  def chain(); end

  def chain=(chain); end

  def clone(chain, klass); end

  def end(key=T.unsafe(nil), object=T.unsafe(nil)); end

  def filter(); end

  def filter=(filter); end

  def initialize(chain, filter, kind, options, klass); end

  def kind(); end

  def kind=(kind); end

  def klass(); end

  def klass=(klass); end

  def matches?(_kind, _filter); end

  def name(); end

  def next_id(); end

  def normalize_options!(options); end

  def options(); end

  def options=(options); end

  def per_key(); end

  def per_key=(per_key); end

  def raw_filter(); end

  def raw_filter=(raw_filter); end

  def recompile!(_options, _per_key); end

  def start(key=T.unsafe(nil), object=T.unsafe(nil)); end
end

class ActiveSupport::Callbacks::Callback
end

class ActiveSupport::Callbacks::CallbackChain
  def compile(key=T.unsafe(nil), object=T.unsafe(nil)); end

  def config(); end

  def initialize(name, config); end

  def name(); end
end

class ActiveSupport::Callbacks::CallbackChain
end

module ActiveSupport::Callbacks::ClassMethods
  def __callback_runner_name(key, kind); end

  def __define_runner(symbol); end

  def __reset_runner(symbol); end

  def __run_callback(key, kind, object, &blk); end

  def __update_callbacks(name, filters=T.unsafe(nil), block=T.unsafe(nil)); end

  def define_callbacks(*callbacks); end

  def reset_callbacks(symbol); end

  def set_callback(name, *filter_list, &block); end

  def skip_callback(name, *filter_list, &block); end
end

module ActiveSupport::Callbacks::ClassMethods
end

module ActiveSupport::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Configurable
  def config(); end
end

module ActiveSupport::Configurable::ClassMethods
  def config(); end

  def config_accessor(*names); end

  def configure(); end
end

module ActiveSupport::Configurable::ClassMethods
end

class ActiveSupport::Configurable::Configuration
  def compile_methods!(); end
end

class ActiveSupport::Configurable::Configuration
  def self.compile_methods!(keys); end
end

module ActiveSupport::Configurable
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Deprecation
  DEFAULT_BEHAVIORS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::DescendantsTracker
  def descendants(); end

  def direct_descendants(); end

  def inherited(base); end
end

module ActiveSupport::DescendantsTracker
  def self.clear(); end

  def self.descendants(klass); end

  def self.direct_descendants(klass); end
end

class ActiveSupport::FileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::FileUpdateChecker
end

ActiveSupport::FrozenObjectError = RuntimeError

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  def self.compress(source); end

  def self.decompress(source); end
end

class ActiveSupport::InheritableOptions
  def inheritable_copy(); end

  def initialize(parent=T.unsafe(nil)); end
end

class ActiveSupport::InheritableOptions
end

module ActiveSupport::JSON
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::JSON::Encoding
  ESCAPED_CHARS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::JSON::Encoding::CircularReferenceError
end

class ActiveSupport::JSON::Encoding::CircularReferenceError
end

class ActiveSupport::JSON::Encoding::Encoder
  def as_json(value, use_options=T.unsafe(nil)); end

  def encode(value, use_options=T.unsafe(nil)); end

  def escape(string); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def options_for(value); end
end

class ActiveSupport::JSON::Encoding::Encoder
end

module ActiveSupport::JSON::Encoding
  def self.escape(string); end

  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(value); end

  def self.escape_regex(); end

  def self.escape_regex=(escape_regex); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

class ActiveSupport::JSON::Variable
end

class ActiveSupport::JSON::Variable
end

module ActiveSupport::JSON
  def self.backend(); end

  def self.backend=(name); end

  def self.decode(json, options=T.unsafe(nil)); end

  def self.encode(value, options=T.unsafe(nil)); end

  def self.engine(); end

  def self.engine=(name); end

  def self.parse_error(); end

  def self.with_backend(name); end
end

class ActiveSupport::LogSubscriber
  def call(message, *args); end

  def color(text, color, bold=T.unsafe(nil)); end

  def colorize_logging(); end

  def colorize_logging=(obj); end

  def debug(*args, &block); end

  def error(*args, &block); end

  def fatal(*args, &block); end

  def format_duration(duration); end

  def info(*args, &block); end

  def logger(); end

  def logger=(logger); end

  def logger?(); end

  def unknown(*args, &block); end

  def warn(*args, &block); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LogSubscriber
  def self.attach_to(namespace, log_subscriber=T.unsafe(nil), notifier=T.unsafe(nil)); end

  def self.colorize_logging(); end

  def self.colorize_logging=(obj); end

  def self.flush_all!(); end

  def self.flushable_loggers(); end

  def self.log_subscribers(); end

  def self.logger(); end

  def self.logger=(val); end

  def self.logger?(); end
end

module ActiveSupport::Memoizable
  def memoize(*symbols); end
end

module ActiveSupport::Memoizable::InstanceMethods
  def flush_cache(*syms); end

  def freeze_with_memoizable(); end

  def memoize_all(); end

  def prime_cache(*syms); end

  def unmemoize_all(); end
end

module ActiveSupport::Memoizable::InstanceMethods
  def self.included(base); end
end

module ActiveSupport::Memoizable
  def self.extended(base); end

  def self.memoized_ivar_for(symbol); end
end

class ActiveSupport::MessageEncryptor
  def decrypt(value); end

  def decrypt_and_verify(value); end

  def encrypt(value); end

  def encrypt_and_sign(value); end

  def initialize(secret, options=T.unsafe(nil)); end
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

module ActiveSupport::MessageEncryptor::NullSerializer
end

module ActiveSupport::MessageEncryptor::NullSerializer
  def self.dump(value); end

  def self.load(value); end
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageEncryptor
end

class ActiveSupport::MessageVerifier
  def generate(value); end

  def initialize(secret, options=T.unsafe(nil)); end

  def verify(signed_message); end
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier
end

module ActiveSupport::Multibyte
  VALID_CHARACTER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable
  def =~(other); end

  def [](*args); end

  def []=(*args); end

  def acts_like_string?(); end

  def capitalize(); end

  def capitalize!(*args); end

  def chars(string); end

  def compose(); end

  def decompose(); end

  def downcase(); end

  def downcase!(*args); end

  def g_length(); end

  def initialize(string); end

  def justify(integer, way, padstr=T.unsafe(nil)); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def padding(padsize, padstr=T.unsafe(nil)); end

  def respond_to?(method, include_private=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def translate_offset(byte_offset); end

  def upcase(); end

  def upcase!(*args); end

  def wrapped_string(); end
end

class ActiveSupport::Multibyte::Chars
  def self.consumes?(string); end
end

class ActiveSupport::Multibyte::EncodingError
end

class ActiveSupport::Multibyte::EncodingError
end

module ActiveSupport::Multibyte::Unicode
  def apply_mapping(string, mapping); end

  def compose_codepoints(codepoints); end

  def decompose_codepoints(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def g_pack(unpacked); end

  def g_unpack(string); end

  def in_char_class?(codepoint, classes); end

  def normalize(string, form=T.unsafe(nil)); end

  def reorder_characters(codepoints); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def u_unpack(string); end
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  LEADERS_PAT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Unicode::Codepoint
  def code(); end

  def code=(code); end

  def combining_class(); end

  def combining_class=(combining_class); end

  def decomp_mapping(); end

  def decomp_mapping=(decomp_mapping); end

  def decomp_type(); end

  def decomp_type=(decomp_type); end

  def lowercase_mapping(); end

  def lowercase_mapping=(lowercase_mapping); end

  def uppercase_mapping(); end

  def uppercase_mapping=(uppercase_mapping); end
end

class ActiveSupport::Multibyte::Unicode::Codepoint
end

class ActiveSupport::Multibyte::Unicode::UnicodeDatabase
  def boundary(); end

  def boundary=(boundary); end

  def codepoints(); end

  def codepoints=(codepoints); end

  def composition_exclusion(); end

  def composition_exclusion=(composition_exclusion); end

  def composition_map(); end

  def composition_map=(composition_map); end

  def cp1252(); end

  def cp1252=(cp1252); end

  def load(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Unicode::UnicodeDatabase
  def self.dirname(); end

  def self.filename(); end
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode
  def self.codepoints_to_pattern(array_of_codepoints); end
end

class ActiveSupport::Notifications::Event
  def duration(); end

  def end(); end

  def initialize(name, start, ending, transaction_id, payload); end

  def name(); end

  def parent_of?(event); end

  def payload(); end

  def time(); end

  def transaction_id(); end
end

class ActiveSupport::Notifications::Event
end

class ActiveSupport::Notifications::Instrumenter
  def id(); end

  def initialize(notifier); end

  def instrument(name, payload=T.unsafe(nil)); end
end

class ActiveSupport::Notifications::Instrumenter
end

class ActiveSupport::OrderedOptions
  def [](key); end

  def []=(key, value); end

  def _get(_); end

  def method_missing(name, *args); end

  def respond_to?(name); end
end

class ActiveSupport::OrderedOptions
end

module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end

  def rescue_with_handler(exception); end
end

module ActiveSupport::Rescuable::ClassMethods
  def rescue_from(*klasses, &block); end
end

module ActiveSupport::Rescuable::ClassMethods
end

module ActiveSupport::Rescuable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::SafeBuffer
  UNSAFE_STRING_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TaggedLogging
  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def clear_tags!(); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def flush(); end

  def info(progname=T.unsafe(nil), &block); end

  def initialize(logger); end

  def method_missing(method, *args); end

  def pop_tags(size=T.unsafe(nil)); end

  def push_tags(*tags); end

  def silence(*args, &block); end

  def silence_with_deprecation(*args, &block); end

  def silence_without_deprecation(temporary_level=T.unsafe(nil), &block); end

  def tagged(*tags); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
end

class ActiveSupport::TaggedLogging
end

class ActiveSupport::TimeZone
  MAPPING = ::T.let(nil, ::T.untyped)
  UTC_OFFSET_WITHOUT_COLON = ::T.let(nil, ::T.untyped)
  UTC_OFFSET_WITH_COLON = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini_REXML
  CONTENT_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport
  def self.escape_html_entities_in_json(*args, &block); end

  def self.escape_html_entities_in_json=(*args, &block); end

  def self.parse_json_times(); end

  def self.parse_json_times=(obj); end

  def self.use_standard_json_time_format(*args, &block); end

  def self.use_standard_json_time_format=(*args, &block); end
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

module Airrecord
  VERSION = ::T.let(nil, ::T.untyped)
end

class Airrecord::Client
  AIRTABLE_RPS_LIMIT = ::T.let(nil, ::T.untyped)
end

module Airrecord::QueryString::Encodings
  DEFAULT = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def encode_json(encoder); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_h(); end
end

class Array
  def self.wrap(object); end
end

module Aws
  CORE_GEM_VERSION = ::T.let(nil, ::T.untyped)
end

class Aws::ClientSideMonitoring::RequestMetrics
  FIELD_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class Aws::ECSCredentials
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Aws::EndpointCache
  MAX_ENTRIES = ::T.let(nil, ::T.untyped)
  MAX_THREADS = ::T.let(nil, ::T.untyped)
end

class Aws::EndpointCache::Endpoint
  CACHE_PERIOD = ::T.let(nil, ::T.untyped)
end

class Aws::EventStream::Decoder
  ONE_MEGABYTE = ::T.let(nil, ::T.untyped)
  OVERHEAD_LENGTH = ::T.let(nil, ::T.untyped)
  PRELUDE_LENGTH = ::T.let(nil, ::T.untyped)
end

class Aws::EventStream::Encoder
  MAX_HEADERS_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_PAYLOAD_LENGTH = ::T.let(nil, ::T.untyped)
  OVERHEAD_LENGTH = ::T.let(nil, ::T.untyped)
end

class Aws::InstanceProfileCredentials
  METADATA_PATH_BASE = ::T.let(nil, ::T.untyped)
  METADATA_TOKEN_PATH = ::T.let(nil, ::T.untyped)
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

module Aws::Json
  ENGINE_DUMP_OPTIONS = ::T.let(nil, ::T.untyped)
  ENGINE_ERRORS = ::T.let(nil, ::T.untyped)
  ENGINE_LOAD_OPTIONS = ::T.let(nil, ::T.untyped)
end

Aws::Json::ENGINE = JSON

class Aws::Json::Handler
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

module Aws::KMS
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

module Aws::KMS::ClientApi
  API = ::T.let(nil, ::T.untyped)
  AWSAccountIdType = ::T.let(nil, ::T.untyped)
  AlgorithmSpec = ::T.let(nil, ::T.untyped)
  AliasList = ::T.let(nil, ::T.untyped)
  AliasListEntry = ::T.let(nil, ::T.untyped)
  AliasNameType = ::T.let(nil, ::T.untyped)
  AlreadyExistsException = ::T.let(nil, ::T.untyped)
  ArnType = ::T.let(nil, ::T.untyped)
  BooleanType = ::T.let(nil, ::T.untyped)
  CancelKeyDeletionRequest = ::T.let(nil, ::T.untyped)
  CancelKeyDeletionResponse = ::T.let(nil, ::T.untyped)
  CiphertextType = ::T.let(nil, ::T.untyped)
  CloudHsmClusterIdType = ::T.let(nil, ::T.untyped)
  CloudHsmClusterInUseException = ::T.let(nil, ::T.untyped)
  CloudHsmClusterInvalidConfigurationException = ::T.let(nil, ::T.untyped)
  CloudHsmClusterNotActiveException = ::T.let(nil, ::T.untyped)
  CloudHsmClusterNotFoundException = ::T.let(nil, ::T.untyped)
  CloudHsmClusterNotRelatedException = ::T.let(nil, ::T.untyped)
  ConnectCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  ConnectCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  ConnectionErrorCodeType = ::T.let(nil, ::T.untyped)
  ConnectionStateType = ::T.let(nil, ::T.untyped)
  CreateAliasRequest = ::T.let(nil, ::T.untyped)
  CreateCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  CreateCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  CreateGrantRequest = ::T.let(nil, ::T.untyped)
  CreateGrantResponse = ::T.let(nil, ::T.untyped)
  CreateKeyRequest = ::T.let(nil, ::T.untyped)
  CreateKeyResponse = ::T.let(nil, ::T.untyped)
  CustomKeyStoreHasCMKsException = ::T.let(nil, ::T.untyped)
  CustomKeyStoreIdType = ::T.let(nil, ::T.untyped)
  CustomKeyStoreInvalidStateException = ::T.let(nil, ::T.untyped)
  CustomKeyStoreNameInUseException = ::T.let(nil, ::T.untyped)
  CustomKeyStoreNameType = ::T.let(nil, ::T.untyped)
  CustomKeyStoreNotFoundException = ::T.let(nil, ::T.untyped)
  CustomKeyStoresList = ::T.let(nil, ::T.untyped)
  CustomKeyStoresListEntry = ::T.let(nil, ::T.untyped)
  DataKeySpec = ::T.let(nil, ::T.untyped)
  DateType = ::T.let(nil, ::T.untyped)
  DecryptRequest = ::T.let(nil, ::T.untyped)
  DecryptResponse = ::T.let(nil, ::T.untyped)
  DeleteAliasRequest = ::T.let(nil, ::T.untyped)
  DeleteCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  DeleteCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  DeleteImportedKeyMaterialRequest = ::T.let(nil, ::T.untyped)
  DependencyTimeoutException = ::T.let(nil, ::T.untyped)
  DescribeCustomKeyStoresRequest = ::T.let(nil, ::T.untyped)
  DescribeCustomKeyStoresResponse = ::T.let(nil, ::T.untyped)
  DescribeKeyRequest = ::T.let(nil, ::T.untyped)
  DescribeKeyResponse = ::T.let(nil, ::T.untyped)
  DescriptionType = ::T.let(nil, ::T.untyped)
  DisableKeyRequest = ::T.let(nil, ::T.untyped)
  DisableKeyRotationRequest = ::T.let(nil, ::T.untyped)
  DisabledException = ::T.let(nil, ::T.untyped)
  DisconnectCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  DisconnectCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  EnableKeyRequest = ::T.let(nil, ::T.untyped)
  EnableKeyRotationRequest = ::T.let(nil, ::T.untyped)
  EncryptRequest = ::T.let(nil, ::T.untyped)
  EncryptResponse = ::T.let(nil, ::T.untyped)
  EncryptionContextKey = ::T.let(nil, ::T.untyped)
  EncryptionContextType = ::T.let(nil, ::T.untyped)
  EncryptionContextValue = ::T.let(nil, ::T.untyped)
  ErrorMessageType = ::T.let(nil, ::T.untyped)
  ExpirationModelType = ::T.let(nil, ::T.untyped)
  ExpiredImportTokenException = ::T.let(nil, ::T.untyped)
  GenerateDataKeyRequest = ::T.let(nil, ::T.untyped)
  GenerateDataKeyResponse = ::T.let(nil, ::T.untyped)
  GenerateDataKeyWithoutPlaintextRequest = ::T.let(nil, ::T.untyped)
  GenerateDataKeyWithoutPlaintextResponse = ::T.let(nil, ::T.untyped)
  GenerateRandomRequest = ::T.let(nil, ::T.untyped)
  GenerateRandomResponse = ::T.let(nil, ::T.untyped)
  GetKeyPolicyRequest = ::T.let(nil, ::T.untyped)
  GetKeyPolicyResponse = ::T.let(nil, ::T.untyped)
  GetKeyRotationStatusRequest = ::T.let(nil, ::T.untyped)
  GetKeyRotationStatusResponse = ::T.let(nil, ::T.untyped)
  GetParametersForImportRequest = ::T.let(nil, ::T.untyped)
  GetParametersForImportResponse = ::T.let(nil, ::T.untyped)
  GrantConstraints = ::T.let(nil, ::T.untyped)
  GrantIdType = ::T.let(nil, ::T.untyped)
  GrantList = ::T.let(nil, ::T.untyped)
  GrantListEntry = ::T.let(nil, ::T.untyped)
  GrantNameType = ::T.let(nil, ::T.untyped)
  GrantOperation = ::T.let(nil, ::T.untyped)
  GrantOperationList = ::T.let(nil, ::T.untyped)
  GrantTokenList = ::T.let(nil, ::T.untyped)
  GrantTokenType = ::T.let(nil, ::T.untyped)
  ImportKeyMaterialRequest = ::T.let(nil, ::T.untyped)
  ImportKeyMaterialResponse = ::T.let(nil, ::T.untyped)
  IncorrectKeyMaterialException = ::T.let(nil, ::T.untyped)
  IncorrectTrustAnchorException = ::T.let(nil, ::T.untyped)
  InvalidAliasNameException = ::T.let(nil, ::T.untyped)
  InvalidArnException = ::T.let(nil, ::T.untyped)
  InvalidCiphertextException = ::T.let(nil, ::T.untyped)
  InvalidGrantIdException = ::T.let(nil, ::T.untyped)
  InvalidGrantTokenException = ::T.let(nil, ::T.untyped)
  InvalidImportTokenException = ::T.let(nil, ::T.untyped)
  InvalidKeyUsageException = ::T.let(nil, ::T.untyped)
  InvalidMarkerException = ::T.let(nil, ::T.untyped)
  KMSInternalException = ::T.let(nil, ::T.untyped)
  KMSInvalidStateException = ::T.let(nil, ::T.untyped)
  KeyIdType = ::T.let(nil, ::T.untyped)
  KeyList = ::T.let(nil, ::T.untyped)
  KeyListEntry = ::T.let(nil, ::T.untyped)
  KeyManagerType = ::T.let(nil, ::T.untyped)
  KeyMetadata = ::T.let(nil, ::T.untyped)
  KeyState = ::T.let(nil, ::T.untyped)
  KeyStorePasswordType = ::T.let(nil, ::T.untyped)
  KeyUnavailableException = ::T.let(nil, ::T.untyped)
  KeyUsageType = ::T.let(nil, ::T.untyped)
  LimitExceededException = ::T.let(nil, ::T.untyped)
  LimitType = ::T.let(nil, ::T.untyped)
  ListAliasesRequest = ::T.let(nil, ::T.untyped)
  ListAliasesResponse = ::T.let(nil, ::T.untyped)
  ListGrantsRequest = ::T.let(nil, ::T.untyped)
  ListGrantsResponse = ::T.let(nil, ::T.untyped)
  ListKeyPoliciesRequest = ::T.let(nil, ::T.untyped)
  ListKeyPoliciesResponse = ::T.let(nil, ::T.untyped)
  ListKeysRequest = ::T.let(nil, ::T.untyped)
  ListKeysResponse = ::T.let(nil, ::T.untyped)
  ListResourceTagsRequest = ::T.let(nil, ::T.untyped)
  ListResourceTagsResponse = ::T.let(nil, ::T.untyped)
  ListRetirableGrantsRequest = ::T.let(nil, ::T.untyped)
  MalformedPolicyDocumentException = ::T.let(nil, ::T.untyped)
  MarkerType = ::T.let(nil, ::T.untyped)
  NotFoundException = ::T.let(nil, ::T.untyped)
  NumberOfBytesType = ::T.let(nil, ::T.untyped)
  OriginType = ::T.let(nil, ::T.untyped)
  PendingWindowInDaysType = ::T.let(nil, ::T.untyped)
  PlaintextType = ::T.let(nil, ::T.untyped)
  PolicyNameList = ::T.let(nil, ::T.untyped)
  PolicyNameType = ::T.let(nil, ::T.untyped)
  PolicyType = ::T.let(nil, ::T.untyped)
  PrincipalIdType = ::T.let(nil, ::T.untyped)
  PutKeyPolicyRequest = ::T.let(nil, ::T.untyped)
  ReEncryptRequest = ::T.let(nil, ::T.untyped)
  ReEncryptResponse = ::T.let(nil, ::T.untyped)
  RetireGrantRequest = ::T.let(nil, ::T.untyped)
  RevokeGrantRequest = ::T.let(nil, ::T.untyped)
  ScheduleKeyDeletionRequest = ::T.let(nil, ::T.untyped)
  ScheduleKeyDeletionResponse = ::T.let(nil, ::T.untyped)
  Tag = ::T.let(nil, ::T.untyped)
  TagException = ::T.let(nil, ::T.untyped)
  TagKeyList = ::T.let(nil, ::T.untyped)
  TagKeyType = ::T.let(nil, ::T.untyped)
  TagList = ::T.let(nil, ::T.untyped)
  TagResourceRequest = ::T.let(nil, ::T.untyped)
  TagValueType = ::T.let(nil, ::T.untyped)
  TrustAnchorCertificateType = ::T.let(nil, ::T.untyped)
  UnsupportedOperationException = ::T.let(nil, ::T.untyped)
  UntagResourceRequest = ::T.let(nil, ::T.untyped)
  UpdateAliasRequest = ::T.let(nil, ::T.untyped)
  UpdateCustomKeyStoreRequest = ::T.let(nil, ::T.untyped)
  UpdateCustomKeyStoreResponse = ::T.let(nil, ::T.untyped)
  UpdateKeyDescriptionRequest = ::T.let(nil, ::T.untyped)
  WrappingKeySpec = ::T.let(nil, ::T.untyped)
end

class Aws::Log::ParamFilter
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::Log::ParamFormatter
  MAX_STRING_SIZE = ::T.let(nil, ::T.untyped)
end

class Aws::ParamValidator
  EXPECTED_GOT = ::T.let(nil, ::T.untyped)
end

class Aws::Partitions::EndpointProvider
  S3_IAD_REGIONAL = ::T.let(nil, ::T.untyped)
  STS_LEGACY_REGIONS = ::T.let(nil, ::T.untyped)
end

module Aws::Partitions
  extend ::Enumerable
end

class Aws::Plugins::RegionalEndpoint
  MISSING_REGION = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::RetryErrors
  DEFAULT_BACKOFF = ::T.let(nil, ::T.untyped)
  EQUAL_JITTER = ::T.let(nil, ::T.untyped)
  FULL_JITTER = ::T.let(nil, ::T.untyped)
  JITTERS = ::T.let(nil, ::T.untyped)
  NO_JITTER = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::RetryErrors::ErrorInspector
  CHECKSUM_ERRORS = ::T.let(nil, ::T.untyped)
  EXPIRED_CREDS = ::T.let(nil, ::T.untyped)
  NETWORKING_ERRORS = ::T.let(nil, ::T.untyped)
  THROTTLING_ERRORS = ::T.let(nil, ::T.untyped)
end

class Aws::Query::Handler
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  METADATA_REF = ::T.let(nil, ::T.untyped)
end

module Aws::S3
  BUCKET_REGIONS = ::T.let(nil, ::T.untyped)
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

module Aws::S3::ClientApi
  API = ::T.let(nil, ::T.untyped)
  AbortDate = ::T.let(nil, ::T.untyped)
  AbortIncompleteMultipartUpload = ::T.let(nil, ::T.untyped)
  AbortMultipartUploadOutput = ::T.let(nil, ::T.untyped)
  AbortMultipartUploadRequest = ::T.let(nil, ::T.untyped)
  AbortRuleId = ::T.let(nil, ::T.untyped)
  AccelerateConfiguration = ::T.let(nil, ::T.untyped)
  AcceptRanges = ::T.let(nil, ::T.untyped)
  AccessControlPolicy = ::T.let(nil, ::T.untyped)
  AccessControlTranslation = ::T.let(nil, ::T.untyped)
  AccountId = ::T.let(nil, ::T.untyped)
  AllowQuotedRecordDelimiter = ::T.let(nil, ::T.untyped)
  AllowedHeader = ::T.let(nil, ::T.untyped)
  AllowedHeaders = ::T.let(nil, ::T.untyped)
  AllowedMethod = ::T.let(nil, ::T.untyped)
  AllowedMethods = ::T.let(nil, ::T.untyped)
  AllowedOrigin = ::T.let(nil, ::T.untyped)
  AllowedOrigins = ::T.let(nil, ::T.untyped)
  AnalyticsAndOperator = ::T.let(nil, ::T.untyped)
  AnalyticsConfiguration = ::T.let(nil, ::T.untyped)
  AnalyticsConfigurationList = ::T.let(nil, ::T.untyped)
  AnalyticsExportDestination = ::T.let(nil, ::T.untyped)
  AnalyticsFilter = ::T.let(nil, ::T.untyped)
  AnalyticsId = ::T.let(nil, ::T.untyped)
  AnalyticsS3BucketDestination = ::T.let(nil, ::T.untyped)
  AnalyticsS3ExportFileFormat = ::T.let(nil, ::T.untyped)
  Body = ::T.let(nil, ::T.untyped)
  Bucket = ::T.let(nil, ::T.untyped)
  BucketAccelerateStatus = ::T.let(nil, ::T.untyped)
  BucketAlreadyExists = ::T.let(nil, ::T.untyped)
  BucketAlreadyOwnedByYou = ::T.let(nil, ::T.untyped)
  BucketCannedACL = ::T.let(nil, ::T.untyped)
  BucketLifecycleConfiguration = ::T.let(nil, ::T.untyped)
  BucketLocationConstraint = ::T.let(nil, ::T.untyped)
  BucketLoggingStatus = ::T.let(nil, ::T.untyped)
  BucketLogsPermission = ::T.let(nil, ::T.untyped)
  BucketName = ::T.let(nil, ::T.untyped)
  BucketVersioningStatus = ::T.let(nil, ::T.untyped)
  Buckets = ::T.let(nil, ::T.untyped)
  BypassGovernanceRetention = ::T.let(nil, ::T.untyped)
  BytesProcessed = ::T.let(nil, ::T.untyped)
  BytesReturned = ::T.let(nil, ::T.untyped)
  BytesScanned = ::T.let(nil, ::T.untyped)
  CORSConfiguration = ::T.let(nil, ::T.untyped)
  CORSRule = ::T.let(nil, ::T.untyped)
  CORSRules = ::T.let(nil, ::T.untyped)
  CSVInput = ::T.let(nil, ::T.untyped)
  CSVOutput = ::T.let(nil, ::T.untyped)
  CacheControl = ::T.let(nil, ::T.untyped)
  CloudFunction = ::T.let(nil, ::T.untyped)
  CloudFunctionConfiguration = ::T.let(nil, ::T.untyped)
  CloudFunctionInvocationRole = ::T.let(nil, ::T.untyped)
  Code = ::T.let(nil, ::T.untyped)
  Comments = ::T.let(nil, ::T.untyped)
  CommonPrefix = ::T.let(nil, ::T.untyped)
  CommonPrefixList = ::T.let(nil, ::T.untyped)
  CompleteMultipartUploadOutput = ::T.let(nil, ::T.untyped)
  CompleteMultipartUploadRequest = ::T.let(nil, ::T.untyped)
  CompletedMultipartUpload = ::T.let(nil, ::T.untyped)
  CompletedPart = ::T.let(nil, ::T.untyped)
  CompletedPartList = ::T.let(nil, ::T.untyped)
  CompressionType = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  ConfirmRemoveSelfBucketAccess = ::T.let(nil, ::T.untyped)
  ContentDisposition = ::T.let(nil, ::T.untyped)
  ContentEncoding = ::T.let(nil, ::T.untyped)
  ContentLanguage = ::T.let(nil, ::T.untyped)
  ContentLength = ::T.let(nil, ::T.untyped)
  ContentMD5 = ::T.let(nil, ::T.untyped)
  ContentRange = ::T.let(nil, ::T.untyped)
  ContentType = ::T.let(nil, ::T.untyped)
  ContinuationEvent = ::T.let(nil, ::T.untyped)
  CopyObjectOutput = ::T.let(nil, ::T.untyped)
  CopyObjectRequest = ::T.let(nil, ::T.untyped)
  CopyObjectResult = ::T.let(nil, ::T.untyped)
  CopyPartResult = ::T.let(nil, ::T.untyped)
  CopySource = ::T.let(nil, ::T.untyped)
  CopySourceIfMatch = ::T.let(nil, ::T.untyped)
  CopySourceIfModifiedSince = ::T.let(nil, ::T.untyped)
  CopySourceIfNoneMatch = ::T.let(nil, ::T.untyped)
  CopySourceIfUnmodifiedSince = ::T.let(nil, ::T.untyped)
  CopySourceRange = ::T.let(nil, ::T.untyped)
  CopySourceSSECustomerAlgorithm = ::T.let(nil, ::T.untyped)
  CopySourceSSECustomerKey = ::T.let(nil, ::T.untyped)
  CopySourceSSECustomerKeyMD5 = ::T.let(nil, ::T.untyped)
  CopySourceVersionId = ::T.let(nil, ::T.untyped)
  CreateBucketConfiguration = ::T.let(nil, ::T.untyped)
  CreateBucketOutput = ::T.let(nil, ::T.untyped)
  CreateBucketRequest = ::T.let(nil, ::T.untyped)
  CreateMultipartUploadOutput = ::T.let(nil, ::T.untyped)
  CreateMultipartUploadRequest = ::T.let(nil, ::T.untyped)
  CreationDate = ::T.let(nil, ::T.untyped)
  Date = ::T.let(nil, ::T.untyped)
  Days = ::T.let(nil, ::T.untyped)
  DaysAfterInitiation = ::T.let(nil, ::T.untyped)
  DefaultRetention = ::T.let(nil, ::T.untyped)
  Delete = ::T.let(nil, ::T.untyped)
  DeleteBucketAnalyticsConfigurationRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketCorsRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketEncryptionRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketInventoryConfigurationRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketLifecycleRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketMetricsConfigurationRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketPolicyRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketReplicationRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketTaggingRequest = ::T.let(nil, ::T.untyped)
  DeleteBucketWebsiteRequest = ::T.let(nil, ::T.untyped)
  DeleteMarker = ::T.let(nil, ::T.untyped)
  DeleteMarkerEntry = ::T.let(nil, ::T.untyped)
  DeleteMarkerReplication = ::T.let(nil, ::T.untyped)
  DeleteMarkerReplicationStatus = ::T.let(nil, ::T.untyped)
  DeleteMarkerVersionId = ::T.let(nil, ::T.untyped)
  DeleteMarkers = ::T.let(nil, ::T.untyped)
  DeleteObjectOutput = ::T.let(nil, ::T.untyped)
  DeleteObjectRequest = ::T.let(nil, ::T.untyped)
  DeleteObjectTaggingOutput = ::T.let(nil, ::T.untyped)
  DeleteObjectTaggingRequest = ::T.let(nil, ::T.untyped)
  DeleteObjectsOutput = ::T.let(nil, ::T.untyped)
  DeleteObjectsRequest = ::T.let(nil, ::T.untyped)
  DeletePublicAccessBlockRequest = ::T.let(nil, ::T.untyped)
  DeletedObject = ::T.let(nil, ::T.untyped)
  DeletedObjects = ::T.let(nil, ::T.untyped)
  Delimiter = ::T.let(nil, ::T.untyped)
  Description = ::T.let(nil, ::T.untyped)
  Destination = ::T.let(nil, ::T.untyped)
  DisplayName = ::T.let(nil, ::T.untyped)
  ETag = ::T.let(nil, ::T.untyped)
  EmailAddress = ::T.let(nil, ::T.untyped)
  EnableRequestProgress = ::T.let(nil, ::T.untyped)
  EncodingType = ::T.let(nil, ::T.untyped)
  Encryption = ::T.let(nil, ::T.untyped)
  EncryptionConfiguration = ::T.let(nil, ::T.untyped)
  End = ::T.let(nil, ::T.untyped)
  EndEvent = ::T.let(nil, ::T.untyped)
  Error = ::T.let(nil, ::T.untyped)
  ErrorDocument = ::T.let(nil, ::T.untyped)
  Errors = ::T.let(nil, ::T.untyped)
  Event = ::T.let(nil, ::T.untyped)
  EventList = ::T.let(nil, ::T.untyped)
  ExistingObjectReplication = ::T.let(nil, ::T.untyped)
  ExistingObjectReplicationStatus = ::T.let(nil, ::T.untyped)
  Expiration = ::T.let(nil, ::T.untyped)
  ExpirationStatus = ::T.let(nil, ::T.untyped)
  ExpiredObjectDeleteMarker = ::T.let(nil, ::T.untyped)
  Expires = ::T.let(nil, ::T.untyped)
  ExpiresString = ::T.let(nil, ::T.untyped)
  ExposeHeader = ::T.let(nil, ::T.untyped)
  ExposeHeaders = ::T.let(nil, ::T.untyped)
  Expression = ::T.let(nil, ::T.untyped)
  ExpressionType = ::T.let(nil, ::T.untyped)
  FetchOwner = ::T.let(nil, ::T.untyped)
  FieldDelimiter = ::T.let(nil, ::T.untyped)
  FileHeaderInfo = ::T.let(nil, ::T.untyped)
  FilterRule = ::T.let(nil, ::T.untyped)
  FilterRuleList = ::T.let(nil, ::T.untyped)
  FilterRuleName = ::T.let(nil, ::T.untyped)
  FilterRuleValue = ::T.let(nil, ::T.untyped)
  GetBucketAccelerateConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketAccelerateConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketAclOutput = ::T.let(nil, ::T.untyped)
  GetBucketAclRequest = ::T.let(nil, ::T.untyped)
  GetBucketAnalyticsConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketAnalyticsConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketCorsOutput = ::T.let(nil, ::T.untyped)
  GetBucketCorsRequest = ::T.let(nil, ::T.untyped)
  GetBucketEncryptionOutput = ::T.let(nil, ::T.untyped)
  GetBucketEncryptionRequest = ::T.let(nil, ::T.untyped)
  GetBucketInventoryConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketInventoryConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketLifecycleConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketLifecycleConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketLifecycleOutput = ::T.let(nil, ::T.untyped)
  GetBucketLifecycleRequest = ::T.let(nil, ::T.untyped)
  GetBucketLocationOutput = ::T.let(nil, ::T.untyped)
  GetBucketLocationRequest = ::T.let(nil, ::T.untyped)
  GetBucketLoggingOutput = ::T.let(nil, ::T.untyped)
  GetBucketLoggingRequest = ::T.let(nil, ::T.untyped)
  GetBucketMetricsConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetBucketMetricsConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketNotificationConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetBucketPolicyOutput = ::T.let(nil, ::T.untyped)
  GetBucketPolicyRequest = ::T.let(nil, ::T.untyped)
  GetBucketPolicyStatusOutput = ::T.let(nil, ::T.untyped)
  GetBucketPolicyStatusRequest = ::T.let(nil, ::T.untyped)
  GetBucketReplicationOutput = ::T.let(nil, ::T.untyped)
  GetBucketReplicationRequest = ::T.let(nil, ::T.untyped)
  GetBucketRequestPaymentOutput = ::T.let(nil, ::T.untyped)
  GetBucketRequestPaymentRequest = ::T.let(nil, ::T.untyped)
  GetBucketTaggingOutput = ::T.let(nil, ::T.untyped)
  GetBucketTaggingRequest = ::T.let(nil, ::T.untyped)
  GetBucketVersioningOutput = ::T.let(nil, ::T.untyped)
  GetBucketVersioningRequest = ::T.let(nil, ::T.untyped)
  GetBucketWebsiteOutput = ::T.let(nil, ::T.untyped)
  GetBucketWebsiteRequest = ::T.let(nil, ::T.untyped)
  GetObjectAclOutput = ::T.let(nil, ::T.untyped)
  GetObjectAclRequest = ::T.let(nil, ::T.untyped)
  GetObjectLegalHoldOutput = ::T.let(nil, ::T.untyped)
  GetObjectLegalHoldRequest = ::T.let(nil, ::T.untyped)
  GetObjectLockConfigurationOutput = ::T.let(nil, ::T.untyped)
  GetObjectLockConfigurationRequest = ::T.let(nil, ::T.untyped)
  GetObjectOutput = ::T.let(nil, ::T.untyped)
  GetObjectRequest = ::T.let(nil, ::T.untyped)
  GetObjectRetentionOutput = ::T.let(nil, ::T.untyped)
  GetObjectRetentionRequest = ::T.let(nil, ::T.untyped)
  GetObjectTaggingOutput = ::T.let(nil, ::T.untyped)
  GetObjectTaggingRequest = ::T.let(nil, ::T.untyped)
  GetObjectTorrentOutput = ::T.let(nil, ::T.untyped)
  GetObjectTorrentRequest = ::T.let(nil, ::T.untyped)
  GetPublicAccessBlockOutput = ::T.let(nil, ::T.untyped)
  GetPublicAccessBlockRequest = ::T.let(nil, ::T.untyped)
  GlacierJobParameters = ::T.let(nil, ::T.untyped)
  Grant = ::T.let(nil, ::T.untyped)
  GrantFullControl = ::T.let(nil, ::T.untyped)
  GrantRead = ::T.let(nil, ::T.untyped)
  GrantReadACP = ::T.let(nil, ::T.untyped)
  GrantWrite = ::T.let(nil, ::T.untyped)
  GrantWriteACP = ::T.let(nil, ::T.untyped)
  Grantee = ::T.let(nil, ::T.untyped)
  Grants = ::T.let(nil, ::T.untyped)
  HeadBucketRequest = ::T.let(nil, ::T.untyped)
  HeadObjectOutput = ::T.let(nil, ::T.untyped)
  HeadObjectRequest = ::T.let(nil, ::T.untyped)
  HostName = ::T.let(nil, ::T.untyped)
  HttpErrorCodeReturnedEquals = ::T.let(nil, ::T.untyped)
  HttpRedirectCode = ::T.let(nil, ::T.untyped)
  ID = ::T.let(nil, ::T.untyped)
  IfMatch = ::T.let(nil, ::T.untyped)
  IfModifiedSince = ::T.let(nil, ::T.untyped)
  IfNoneMatch = ::T.let(nil, ::T.untyped)
  IfUnmodifiedSince = ::T.let(nil, ::T.untyped)
  IndexDocument = ::T.let(nil, ::T.untyped)
  Initiated = ::T.let(nil, ::T.untyped)
  Initiator = ::T.let(nil, ::T.untyped)
  InputSerialization = ::T.let(nil, ::T.untyped)
  InventoryConfiguration = ::T.let(nil, ::T.untyped)
  InventoryConfigurationList = ::T.let(nil, ::T.untyped)
  InventoryDestination = ::T.let(nil, ::T.untyped)
  InventoryEncryption = ::T.let(nil, ::T.untyped)
  InventoryFilter = ::T.let(nil, ::T.untyped)
  InventoryFormat = ::T.let(nil, ::T.untyped)
  InventoryFrequency = ::T.let(nil, ::T.untyped)
  InventoryId = ::T.let(nil, ::T.untyped)
  InventoryIncludedObjectVersions = ::T.let(nil, ::T.untyped)
  InventoryOptionalField = ::T.let(nil, ::T.untyped)
  InventoryOptionalFields = ::T.let(nil, ::T.untyped)
  InventoryS3BucketDestination = ::T.let(nil, ::T.untyped)
  InventorySchedule = ::T.let(nil, ::T.untyped)
  IsEnabled = ::T.let(nil, ::T.untyped)
  IsLatest = ::T.let(nil, ::T.untyped)
  IsPublic = ::T.let(nil, ::T.untyped)
  IsTruncated = ::T.let(nil, ::T.untyped)
  JSONInput = ::T.let(nil, ::T.untyped)
  JSONOutput = ::T.let(nil, ::T.untyped)
  JSONType = ::T.let(nil, ::T.untyped)
  KMSContext = ::T.let(nil, ::T.untyped)
  KeyCount = ::T.let(nil, ::T.untyped)
  KeyMarker = ::T.let(nil, ::T.untyped)
  KeyPrefixEquals = ::T.let(nil, ::T.untyped)
  LambdaFunctionArn = ::T.let(nil, ::T.untyped)
  LambdaFunctionConfiguration = ::T.let(nil, ::T.untyped)
  LambdaFunctionConfigurationList = ::T.let(nil, ::T.untyped)
  LastModified = ::T.let(nil, ::T.untyped)
  LifecycleConfiguration = ::T.let(nil, ::T.untyped)
  LifecycleExpiration = ::T.let(nil, ::T.untyped)
  LifecycleRule = ::T.let(nil, ::T.untyped)
  LifecycleRuleAndOperator = ::T.let(nil, ::T.untyped)
  LifecycleRuleFilter = ::T.let(nil, ::T.untyped)
  LifecycleRules = ::T.let(nil, ::T.untyped)
  ListBucketAnalyticsConfigurationsOutput = ::T.let(nil, ::T.untyped)
  ListBucketAnalyticsConfigurationsRequest = ::T.let(nil, ::T.untyped)
  ListBucketInventoryConfigurationsOutput = ::T.let(nil, ::T.untyped)
  ListBucketInventoryConfigurationsRequest = ::T.let(nil, ::T.untyped)
  ListBucketMetricsConfigurationsOutput = ::T.let(nil, ::T.untyped)
  ListBucketMetricsConfigurationsRequest = ::T.let(nil, ::T.untyped)
  ListBucketsOutput = ::T.let(nil, ::T.untyped)
  ListMultipartUploadsOutput = ::T.let(nil, ::T.untyped)
  ListMultipartUploadsRequest = ::T.let(nil, ::T.untyped)
  ListObjectVersionsOutput = ::T.let(nil, ::T.untyped)
  ListObjectVersionsRequest = ::T.let(nil, ::T.untyped)
  ListObjectsOutput = ::T.let(nil, ::T.untyped)
  ListObjectsRequest = ::T.let(nil, ::T.untyped)
  ListObjectsV2Output = ::T.let(nil, ::T.untyped)
  ListObjectsV2Request = ::T.let(nil, ::T.untyped)
  ListPartsOutput = ::T.let(nil, ::T.untyped)
  ListPartsRequest = ::T.let(nil, ::T.untyped)
  Location = ::T.let(nil, ::T.untyped)
  LocationPrefix = ::T.let(nil, ::T.untyped)
  LoggingEnabled = ::T.let(nil, ::T.untyped)
  MFA = ::T.let(nil, ::T.untyped)
  MFADelete = ::T.let(nil, ::T.untyped)
  MFADeleteStatus = ::T.let(nil, ::T.untyped)
  Marker = ::T.let(nil, ::T.untyped)
  MaxAgeSeconds = ::T.let(nil, ::T.untyped)
  MaxKeys = ::T.let(nil, ::T.untyped)
  MaxParts = ::T.let(nil, ::T.untyped)
  MaxUploads = ::T.let(nil, ::T.untyped)
  Message = ::T.let(nil, ::T.untyped)
  Metadata = ::T.let(nil, ::T.untyped)
  MetadataDirective = ::T.let(nil, ::T.untyped)
  MetadataEntry = ::T.let(nil, ::T.untyped)
  MetadataKey = ::T.let(nil, ::T.untyped)
  MetadataValue = ::T.let(nil, ::T.untyped)
  Metrics = ::T.let(nil, ::T.untyped)
  MetricsAndOperator = ::T.let(nil, ::T.untyped)
  MetricsConfiguration = ::T.let(nil, ::T.untyped)
  MetricsConfigurationList = ::T.let(nil, ::T.untyped)
  MetricsFilter = ::T.let(nil, ::T.untyped)
  MetricsId = ::T.let(nil, ::T.untyped)
  MetricsStatus = ::T.let(nil, ::T.untyped)
  Minutes = ::T.let(nil, ::T.untyped)
  MissingMeta = ::T.let(nil, ::T.untyped)
  MultipartUpload = ::T.let(nil, ::T.untyped)
  MultipartUploadId = ::T.let(nil, ::T.untyped)
  MultipartUploadList = ::T.let(nil, ::T.untyped)
  NextKeyMarker = ::T.let(nil, ::T.untyped)
  NextMarker = ::T.let(nil, ::T.untyped)
  NextPartNumberMarker = ::T.let(nil, ::T.untyped)
  NextToken = ::T.let(nil, ::T.untyped)
  NextUploadIdMarker = ::T.let(nil, ::T.untyped)
  NextVersionIdMarker = ::T.let(nil, ::T.untyped)
  NoSuchBucket = ::T.let(nil, ::T.untyped)
  NoSuchKey = ::T.let(nil, ::T.untyped)
  NoSuchUpload = ::T.let(nil, ::T.untyped)
  NoncurrentVersionExpiration = ::T.let(nil, ::T.untyped)
  NoncurrentVersionTransition = ::T.let(nil, ::T.untyped)
  NoncurrentVersionTransitionList = ::T.let(nil, ::T.untyped)
  NotificationConfiguration = ::T.let(nil, ::T.untyped)
  NotificationConfigurationDeprecated = ::T.let(nil, ::T.untyped)
  NotificationConfigurationFilter = ::T.let(nil, ::T.untyped)
  NotificationId = ::T.let(nil, ::T.untyped)
  Object = ::T.let(nil, ::T.untyped)
  ObjectAlreadyInActiveTierError = ::T.let(nil, ::T.untyped)
  ObjectCannedACL = ::T.let(nil, ::T.untyped)
  ObjectIdentifier = ::T.let(nil, ::T.untyped)
  ObjectIdentifierList = ::T.let(nil, ::T.untyped)
  ObjectKey = ::T.let(nil, ::T.untyped)
  ObjectList = ::T.let(nil, ::T.untyped)
  ObjectLockConfiguration = ::T.let(nil, ::T.untyped)
  ObjectLockEnabled = ::T.let(nil, ::T.untyped)
  ObjectLockEnabledForBucket = ::T.let(nil, ::T.untyped)
  ObjectLockLegalHold = ::T.let(nil, ::T.untyped)
  ObjectLockLegalHoldStatus = ::T.let(nil, ::T.untyped)
  ObjectLockMode = ::T.let(nil, ::T.untyped)
  ObjectLockRetainUntilDate = ::T.let(nil, ::T.untyped)
  ObjectLockRetention = ::T.let(nil, ::T.untyped)
  ObjectLockRetentionMode = ::T.let(nil, ::T.untyped)
  ObjectLockRule = ::T.let(nil, ::T.untyped)
  ObjectLockToken = ::T.let(nil, ::T.untyped)
  ObjectNotInActiveTierError = ::T.let(nil, ::T.untyped)
  ObjectStorageClass = ::T.let(nil, ::T.untyped)
  ObjectVersion = ::T.let(nil, ::T.untyped)
  ObjectVersionId = ::T.let(nil, ::T.untyped)
  ObjectVersionList = ::T.let(nil, ::T.untyped)
  ObjectVersionStorageClass = ::T.let(nil, ::T.untyped)
  OutputLocation = ::T.let(nil, ::T.untyped)
  OutputSerialization = ::T.let(nil, ::T.untyped)
  Owner = ::T.let(nil, ::T.untyped)
  OwnerOverride = ::T.let(nil, ::T.untyped)
  ParquetInput = ::T.let(nil, ::T.untyped)
  Part = ::T.let(nil, ::T.untyped)
  PartNumber = ::T.let(nil, ::T.untyped)
  PartNumberMarker = ::T.let(nil, ::T.untyped)
  Parts = ::T.let(nil, ::T.untyped)
  PartsCount = ::T.let(nil, ::T.untyped)
  Payer = ::T.let(nil, ::T.untyped)
  Permission = ::T.let(nil, ::T.untyped)
  Policy = ::T.let(nil, ::T.untyped)
  PolicyStatus = ::T.let(nil, ::T.untyped)
  Prefix = ::T.let(nil, ::T.untyped)
  Priority = ::T.let(nil, ::T.untyped)
  Progress = ::T.let(nil, ::T.untyped)
  ProgressEvent = ::T.let(nil, ::T.untyped)
  Protocol = ::T.let(nil, ::T.untyped)
  PublicAccessBlockConfiguration = ::T.let(nil, ::T.untyped)
  PutBucketAccelerateConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketAclRequest = ::T.let(nil, ::T.untyped)
  PutBucketAnalyticsConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketCorsRequest = ::T.let(nil, ::T.untyped)
  PutBucketEncryptionRequest = ::T.let(nil, ::T.untyped)
  PutBucketInventoryConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketLifecycleConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketLifecycleRequest = ::T.let(nil, ::T.untyped)
  PutBucketLoggingRequest = ::T.let(nil, ::T.untyped)
  PutBucketMetricsConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketNotificationConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutBucketNotificationRequest = ::T.let(nil, ::T.untyped)
  PutBucketPolicyRequest = ::T.let(nil, ::T.untyped)
  PutBucketReplicationRequest = ::T.let(nil, ::T.untyped)
  PutBucketRequestPaymentRequest = ::T.let(nil, ::T.untyped)
  PutBucketTaggingRequest = ::T.let(nil, ::T.untyped)
  PutBucketVersioningRequest = ::T.let(nil, ::T.untyped)
  PutBucketWebsiteRequest = ::T.let(nil, ::T.untyped)
  PutObjectAclOutput = ::T.let(nil, ::T.untyped)
  PutObjectAclRequest = ::T.let(nil, ::T.untyped)
  PutObjectLegalHoldOutput = ::T.let(nil, ::T.untyped)
  PutObjectLegalHoldRequest = ::T.let(nil, ::T.untyped)
  PutObjectLockConfigurationOutput = ::T.let(nil, ::T.untyped)
  PutObjectLockConfigurationRequest = ::T.let(nil, ::T.untyped)
  PutObjectOutput = ::T.let(nil, ::T.untyped)
  PutObjectRequest = ::T.let(nil, ::T.untyped)
  PutObjectRetentionOutput = ::T.let(nil, ::T.untyped)
  PutObjectRetentionRequest = ::T.let(nil, ::T.untyped)
  PutObjectTaggingOutput = ::T.let(nil, ::T.untyped)
  PutObjectTaggingRequest = ::T.let(nil, ::T.untyped)
  PutPublicAccessBlockRequest = ::T.let(nil, ::T.untyped)
  QueueArn = ::T.let(nil, ::T.untyped)
  QueueConfiguration = ::T.let(nil, ::T.untyped)
  QueueConfigurationDeprecated = ::T.let(nil, ::T.untyped)
  QueueConfigurationList = ::T.let(nil, ::T.untyped)
  Quiet = ::T.let(nil, ::T.untyped)
  QuoteCharacter = ::T.let(nil, ::T.untyped)
  QuoteEscapeCharacter = ::T.let(nil, ::T.untyped)
  QuoteFields = ::T.let(nil, ::T.untyped)
  Range = ::T.let(nil, ::T.untyped)
  RecordDelimiter = ::T.let(nil, ::T.untyped)
  RecordsEvent = ::T.let(nil, ::T.untyped)
  Redirect = ::T.let(nil, ::T.untyped)
  RedirectAllRequestsTo = ::T.let(nil, ::T.untyped)
  ReplaceKeyPrefixWith = ::T.let(nil, ::T.untyped)
  ReplaceKeyWith = ::T.let(nil, ::T.untyped)
  ReplicaKmsKeyID = ::T.let(nil, ::T.untyped)
  ReplicationConfiguration = ::T.let(nil, ::T.untyped)
  ReplicationRule = ::T.let(nil, ::T.untyped)
  ReplicationRuleAndOperator = ::T.let(nil, ::T.untyped)
  ReplicationRuleFilter = ::T.let(nil, ::T.untyped)
  ReplicationRuleStatus = ::T.let(nil, ::T.untyped)
  ReplicationRules = ::T.let(nil, ::T.untyped)
  ReplicationStatus = ::T.let(nil, ::T.untyped)
  ReplicationTime = ::T.let(nil, ::T.untyped)
  ReplicationTimeStatus = ::T.let(nil, ::T.untyped)
  ReplicationTimeValue = ::T.let(nil, ::T.untyped)
  RequestCharged = ::T.let(nil, ::T.untyped)
  RequestPayer = ::T.let(nil, ::T.untyped)
  RequestPaymentConfiguration = ::T.let(nil, ::T.untyped)
  RequestProgress = ::T.let(nil, ::T.untyped)
  ResponseCacheControl = ::T.let(nil, ::T.untyped)
  ResponseContentDisposition = ::T.let(nil, ::T.untyped)
  ResponseContentEncoding = ::T.let(nil, ::T.untyped)
  ResponseContentLanguage = ::T.let(nil, ::T.untyped)
  ResponseContentType = ::T.let(nil, ::T.untyped)
  ResponseExpires = ::T.let(nil, ::T.untyped)
  Restore = ::T.let(nil, ::T.untyped)
  RestoreObjectOutput = ::T.let(nil, ::T.untyped)
  RestoreObjectRequest = ::T.let(nil, ::T.untyped)
  RestoreOutputPath = ::T.let(nil, ::T.untyped)
  RestoreRequest = ::T.let(nil, ::T.untyped)
  RestoreRequestType = ::T.let(nil, ::T.untyped)
  Role = ::T.let(nil, ::T.untyped)
  RoutingRule = ::T.let(nil, ::T.untyped)
  RoutingRules = ::T.let(nil, ::T.untyped)
  Rule = ::T.let(nil, ::T.untyped)
  Rules = ::T.let(nil, ::T.untyped)
  S3KeyFilter = ::T.let(nil, ::T.untyped)
  S3Location = ::T.let(nil, ::T.untyped)
  SSECustomerAlgorithm = ::T.let(nil, ::T.untyped)
  SSECustomerKey = ::T.let(nil, ::T.untyped)
  SSECustomerKeyMD5 = ::T.let(nil, ::T.untyped)
  SSEKMS = ::T.let(nil, ::T.untyped)
  SSEKMSEncryptionContext = ::T.let(nil, ::T.untyped)
  SSEKMSKeyId = ::T.let(nil, ::T.untyped)
  SSES3 = ::T.let(nil, ::T.untyped)
  ScanRange = ::T.let(nil, ::T.untyped)
  SelectObjectContentEventStream = ::T.let(nil, ::T.untyped)
  SelectObjectContentOutput = ::T.let(nil, ::T.untyped)
  SelectObjectContentRequest = ::T.let(nil, ::T.untyped)
  SelectParameters = ::T.let(nil, ::T.untyped)
  ServerSideEncryption = ::T.let(nil, ::T.untyped)
  ServerSideEncryptionByDefault = ::T.let(nil, ::T.untyped)
  ServerSideEncryptionConfiguration = ::T.let(nil, ::T.untyped)
  ServerSideEncryptionRule = ::T.let(nil, ::T.untyped)
  ServerSideEncryptionRules = ::T.let(nil, ::T.untyped)
  Setting = ::T.let(nil, ::T.untyped)
  Size = ::T.let(nil, ::T.untyped)
  SourceSelectionCriteria = ::T.let(nil, ::T.untyped)
  SseKmsEncryptedObjects = ::T.let(nil, ::T.untyped)
  SseKmsEncryptedObjectsStatus = ::T.let(nil, ::T.untyped)
  Start = ::T.let(nil, ::T.untyped)
  StartAfter = ::T.let(nil, ::T.untyped)
  Stats = ::T.let(nil, ::T.untyped)
  StatsEvent = ::T.let(nil, ::T.untyped)
  StorageClass = ::T.let(nil, ::T.untyped)
  StorageClassAnalysis = ::T.let(nil, ::T.untyped)
  StorageClassAnalysisDataExport = ::T.let(nil, ::T.untyped)
  StorageClassAnalysisSchemaVersion = ::T.let(nil, ::T.untyped)
  Suffix = ::T.let(nil, ::T.untyped)
  Tag = ::T.let(nil, ::T.untyped)
  TagCount = ::T.let(nil, ::T.untyped)
  TagSet = ::T.let(nil, ::T.untyped)
  Tagging = ::T.let(nil, ::T.untyped)
  TaggingDirective = ::T.let(nil, ::T.untyped)
  TaggingHeader = ::T.let(nil, ::T.untyped)
  TargetBucket = ::T.let(nil, ::T.untyped)
  TargetGrant = ::T.let(nil, ::T.untyped)
  TargetGrants = ::T.let(nil, ::T.untyped)
  TargetPrefix = ::T.let(nil, ::T.untyped)
  Tier = ::T.let(nil, ::T.untyped)
  Token = ::T.let(nil, ::T.untyped)
  TopicArn = ::T.let(nil, ::T.untyped)
  TopicConfiguration = ::T.let(nil, ::T.untyped)
  TopicConfigurationDeprecated = ::T.let(nil, ::T.untyped)
  TopicConfigurationList = ::T.let(nil, ::T.untyped)
  Transition = ::T.let(nil, ::T.untyped)
  TransitionList = ::T.let(nil, ::T.untyped)
  TransitionStorageClass = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  URI = ::T.let(nil, ::T.untyped)
  UploadIdMarker = ::T.let(nil, ::T.untyped)
  UploadPartCopyOutput = ::T.let(nil, ::T.untyped)
  UploadPartCopyRequest = ::T.let(nil, ::T.untyped)
  UploadPartOutput = ::T.let(nil, ::T.untyped)
  UploadPartRequest = ::T.let(nil, ::T.untyped)
  UserMetadata = ::T.let(nil, ::T.untyped)
  Value = ::T.let(nil, ::T.untyped)
  VersionIdMarker = ::T.let(nil, ::T.untyped)
  VersioningConfiguration = ::T.let(nil, ::T.untyped)
  WebsiteConfiguration = ::T.let(nil, ::T.untyped)
  WebsiteRedirectLocation = ::T.let(nil, ::T.untyped)
  Years = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Encryption::DecryptHandler
  POSSIBLE_ENCRYPTION_FORMATS = ::T.let(nil, ::T.untyped)
  POSSIBLE_ENVELOPE_KEYS = ::T.let(nil, ::T.untyped)
  V1_ENVELOPE_KEYS = ::T.let(nil, ::T.untyped)
  V2_ENVELOPE_KEYS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Encryption::IOEncrypter
  ONE_MEGABYTE = ::T.let(nil, ::T.untyped)
end

module Aws::S3::Encryption::Utils
  UNSAFE_MSG = ::T.let(nil, ::T.untyped)
end

class Aws::S3::FileDownloader
  MAX_PARTS = ::T.let(nil, ::T.untyped)
  MIN_CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  THREAD_COUNT = ::T.let(nil, ::T.untyped)
end

class Aws::S3::FileUploader
  FIFTEEN_MEGABYTES = ::T.let(nil, ::T.untyped)
end

class Aws::S3::LegacySigner
  SIGNED_QUERYSTRING_PARAMS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::MultipartFileUploader
  CREATE_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_TOO_SMALL = ::T.let(nil, ::T.untyped)
  MAX_PARTS = ::T.let(nil, ::T.untyped)
  MIN_PART_SIZE = ::T.let(nil, ::T.untyped)
  THREAD_COUNT = ::T.let(nil, ::T.untyped)
  UPLOAD_PART_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::MultipartStreamUploader
  CREATE_OPTIONS = ::T.let(nil, ::T.untyped)
  PART_SIZE = ::T.let(nil, ::T.untyped)
  TEMPFILE_PREIX = ::T.let(nil, ::T.untyped)
  THREAD_COUNT = ::T.let(nil, ::T.untyped)
  UPLOAD_PART_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::ObjectMultipartCopier
  API_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_TOO_SMALL = ::T.let(nil, ::T.untyped)
  FIVE_MB = ::T.let(nil, ::T.untyped)
  MAX_PARTS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Plugins::Md5s
  REQUIRED_OPERATIONS = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Plugins::Md5s::Handler
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Aws::S3::Presigner
  BLACKLISTED_HEADERS = ::T.let(nil, ::T.untyped)
  FIFTEEN_MINUTES = ::T.let(nil, ::T.untyped)
  ONE_WEEK = ::T.let(nil, ::T.untyped)
end

module Aws::STS
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

module Aws::STS::ClientApi
  API = ::T.let(nil, ::T.untyped)
  AssumeRoleRequest = ::T.let(nil, ::T.untyped)
  AssumeRoleResponse = ::T.let(nil, ::T.untyped)
  AssumeRoleWithSAMLRequest = ::T.let(nil, ::T.untyped)
  AssumeRoleWithSAMLResponse = ::T.let(nil, ::T.untyped)
  AssumeRoleWithWebIdentityRequest = ::T.let(nil, ::T.untyped)
  AssumeRoleWithWebIdentityResponse = ::T.let(nil, ::T.untyped)
  AssumedRoleUser = ::T.let(nil, ::T.untyped)
  Audience = ::T.let(nil, ::T.untyped)
  Credentials = ::T.let(nil, ::T.untyped)
  DecodeAuthorizationMessageRequest = ::T.let(nil, ::T.untyped)
  DecodeAuthorizationMessageResponse = ::T.let(nil, ::T.untyped)
  ExpiredTokenException = ::T.let(nil, ::T.untyped)
  FederatedUser = ::T.let(nil, ::T.untyped)
  GetAccessKeyInfoRequest = ::T.let(nil, ::T.untyped)
  GetAccessKeyInfoResponse = ::T.let(nil, ::T.untyped)
  GetCallerIdentityRequest = ::T.let(nil, ::T.untyped)
  GetCallerIdentityResponse = ::T.let(nil, ::T.untyped)
  GetFederationTokenRequest = ::T.let(nil, ::T.untyped)
  GetFederationTokenResponse = ::T.let(nil, ::T.untyped)
  GetSessionTokenRequest = ::T.let(nil, ::T.untyped)
  GetSessionTokenResponse = ::T.let(nil, ::T.untyped)
  IDPCommunicationErrorException = ::T.let(nil, ::T.untyped)
  IDPRejectedClaimException = ::T.let(nil, ::T.untyped)
  InvalidAuthorizationMessageException = ::T.let(nil, ::T.untyped)
  InvalidIdentityTokenException = ::T.let(nil, ::T.untyped)
  Issuer = ::T.let(nil, ::T.untyped)
  MalformedPolicyDocumentException = ::T.let(nil, ::T.untyped)
  NameQualifier = ::T.let(nil, ::T.untyped)
  PackedPolicyTooLargeException = ::T.let(nil, ::T.untyped)
  PolicyDescriptorType = ::T.let(nil, ::T.untyped)
  RegionDisabledException = ::T.let(nil, ::T.untyped)
  SAMLAssertionType = ::T.let(nil, ::T.untyped)
  Subject = ::T.let(nil, ::T.untyped)
  SubjectType = ::T.let(nil, ::T.untyped)
  Tag = ::T.let(nil, ::T.untyped)
end

class Aws::SharedCredentials
  KEY_MAP = ::T.let(nil, ::T.untyped)
end

class Aws::Waiters::Errors::FailureStateError
  MSG = ::T.let(nil, ::T.untyped)
end

class Aws::Waiters::Errors::NoSuchWaiterError
  MSG = ::T.let(nil, ::T.untyped)
end

class Aws::Waiters::Errors::TooManyAttemptsError
  MSG = ::T.let(nil, ::T.untyped)
end

class Aws::Waiters::Errors::UnexpectedError
  MSG = ::T.let(nil, ::T.untyped)
end

Aws::Waiters::Poller::RAISE_HANDLER = Seahorse::Client::Plugins::RaiseResponseErrors::Handler

Aws::Waiters::Waiter::RAISE_HANDLER = Seahorse::Client::Plugins::RaiseResponseErrors::Handler

class Aws::Xml::Parser
  FRAME_CLASSES = ::T.let(nil, ::T.untyped)
end

BasicObject::BasicObject = BasicObject

class Benchmark::Job
  def initialize(width); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end
end

class Benchmark::Tms
  def to_a(); end
end

class BigDecimal
  def clone(); end
  DEFAULT_STRING_FORMAT = ::T.let(nil, ::T.untyped)
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  YAML_MAPPING = ::T.let(nil, ::T.untyped)
  YAML_TAG = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def irb(); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Vertex
  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration
  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Source::Git
  def glob(); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  Correctable = ::T.let(nil, ::T.untyped)
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end

  def self.with_unbundled_env(); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class CSV
  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def fileno(*args, &block); end

  def flush(*args, &block); end

  def fsync(*args, &block); end

  def internal_encoding(*args, &block); end

  def isatty(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def reopen(*args, &block); end

  def seek(*args, &block); end

  def string(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def tell(*args, &block); end

  def truncate(*args, &block); end

  def tty?(*args, &block); end
  ConverterEncoding = ::T.let(nil, ::T.untyped)
  Converters = ::T.let(nil, ::T.untyped)
  DateMatcher = ::T.let(nil, ::T.untyped)
  DateTimeMatcher = ::T.let(nil, ::T.untyped)
  HeaderConverters = ::T.let(nil, ::T.untyped)
end

class CSV::FieldInfo
  def header(); end

  def header=(_); end

  def index(); end

  def index=(_); end

  def line(); end

  def line=(_); end
end

class CSV::FieldInfo
  def self.[](*_); end

  def self.members(); end
end

class CSV::FieldsConverter
  include ::Enumerable
  def add_converter(name=T.unsafe(nil), &converter); end

  def convert(fields, headers, lineno); end

  def each(&block); end

  def empty?(); end

  def initialize(options=T.unsafe(nil)); end
end

class CSV::FieldsConverter
end

class CSV::MalformedCSVError
  def initialize(message, line_number); end

  def line_number(); end

  def lineno(); end
end

class CSV::Parser
  def column_separator(); end

  def field_size_limit(); end

  def header_row?(); end

  def headers(); end

  def initialize(input, options); end

  def liberal_parsing?(); end

  def line(); end

  def lineno(); end

  def parse(&block); end

  def quote_character(); end

  def return_headers?(); end

  def row_separator(); end

  def skip_blanks?(); end

  def skip_lines(); end

  def unconverted_fields?(); end

  def use_headers?(); end
  SCANNER_TEST = ::T.let(nil, ::T.untyped)
end

class CSV::Parser::InputsScanner
  def each_line(row_separator); end

  def eos?(); end

  def initialize(inputs, encoding, chunk_size: T.unsafe(nil)); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def rest(); end

  def scan(pattern); end

  def scan_all(pattern); end
end

class CSV::Parser::InputsScanner
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::Scanner
  def each_line(row_separator); end

  def initialize(*args); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def scan_all(_); end
end

class CSV::Parser::Scanner
end

class CSV::Parser
end

class CSV::Row
  def dig(index_or_header, *indexes); end

  def each_pair(&block); end

  def empty?(*args, &block); end

  def length(*args, &block); end

  def size(*args, &block); end

  def to_ary(*_); end
end

class CSV::Row
  extend ::Forwardable
end

class CSV::Table
  def empty?(*args, &block); end

  def initialize(array_of_rows, headers: T.unsafe(nil)); end

  def length(*args, &block); end

  def size(*args, &block); end

  def table(); end
end

class CSV::Table
  extend ::Forwardable
end

class CSV::Writer
  def <<(row); end

  def headers(); end

  def initialize(output, options); end

  def lineno(); end

  def rewind(); end
end

class CSV::Writer
end

class CSV
  extend ::Forwardable
end

class Class
  def json_creatable?(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Encoder
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::HTML
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_EXTENSION = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
  TOKEN_KIND_TO_INFO = ::T.let(nil, ::T.untyped)
  TRANSPARENT_TOKEN_KINDS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  CSS_CLASS_PATTERN = ::T.let(nil, ::T.untyped)
end

module CodeRay::Encoders::HTML::Output
  DIV = ::T.let(nil, ::T.untyped)
  PAGE = ::T.let(nil, ::T.untyped)
  SPAN = ::T.let(nil, ::T.untyped)
  TABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

module CodeRay::PluginHost
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Java
  CONSTANTS = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MAGIC_VARIABLES = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  STRING_CONTENT_PATTERN = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  UNICODE_ESCAPE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
  List = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Ruby::Patterns
  BINARY = ::T.let(nil, ::T.untyped)
  CHARACTER = ::T.let(nil, ::T.untyped)
  CLASS_VARIABLE = ::T.let(nil, ::T.untyped)
  CONTROL_META_ESCAPE = ::T.let(nil, ::T.untyped)
  DATA = ::T.let(nil, ::T.untyped)
  DECIMAL = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  EXPONENT = ::T.let(nil, ::T.untyped)
  FANCY_STRING_INTERPRETED = ::T.let(nil, ::T.untyped)
  FANCY_STRING_KIND = ::T.let(nil, ::T.untyped)
  FANCY_STRING_START = ::T.let(nil, ::T.untyped)
  FLOAT_OR_INT = ::T.let(nil, ::T.untyped)
  FLOAT_SUFFIX = ::T.let(nil, ::T.untyped)
  GLOBAL_VARIABLE = ::T.let(nil, ::T.untyped)
  HEREDOC_OPEN = ::T.let(nil, ::T.untyped)
  HEXADECIMAL = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  INSTANCE_VARIABLE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_EXPECTING_VALUE = ::T.let(nil, ::T.untyped)
  KEYWORD_NEW_STATE = ::T.let(nil, ::T.untyped)
  METHOD_AFTER_DOT = ::T.let(nil, ::T.untyped)
  METHOD_NAME = ::T.let(nil, ::T.untyped)
  METHOD_NAME_EX = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OPERATOR = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OR_SYMBOL = ::T.let(nil, ::T.untyped)
  METHOD_SUFFIX = ::T.let(nil, ::T.untyped)
  NUMERIC = ::T.let(nil, ::T.untyped)
  OBJECT_VARIABLE = ::T.let(nil, ::T.untyped)
  OCTAL = ::T.let(nil, ::T.untyped)
  PREDEFINED_CONSTANTS = ::T.let(nil, ::T.untyped)
  PREFIX_VARIABLE = ::T.let(nil, ::T.untyped)
  QUOTE_TO_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP_MODIFIERS = ::T.let(nil, ::T.untyped)
  RUBYDOC = ::T.let(nil, ::T.untyped)
  RUBYDOC_OR_DATA = ::T.let(nil, ::T.untyped)
  SIMPLE_ESCAPE = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  VALUE_FOLLOWS = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Ruby::StringState
  CLOSING_PAREN = ::T.let(nil, ::T.untyped)
  STRING_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Scanner
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::SerializedExecutionDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

class Concurrent::SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

class ConnectionPool
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ConnectionPool::Wrapper
  METHODS = ::T.let(nil, ::T.untyped)
end

class Date
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
  DAYS_INTO_WEEK = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.exists?(_); end
end

class Dotenv::Parser
  LINE = ::T.let(nil, ::T.untyped)
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def initialize(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  def as_json(options=T.unsafe(nil)); end

  def chain(*_); end

  def sum(identity=T.unsafe(nil), &block); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  def encode_json(encoder); end
end

module Faraday
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::EMHttp
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end

  def error_message(client); end

  def parallel?(env); end

  def perform_request(env); end

  def perform_single_request(env); end

  def raise_error(msg); end
end

class Faraday::Adapter::EMHttp::Manager
  def add(); end

  def check_finished(); end

  def perform_request(); end

  def reset(); end

  def run(); end

  def running?(); end
end

class Faraday::Adapter::EMHttp::Manager
end

module Faraday::Adapter::EMHttp::Options
  def configure_compression(options, env); end

  def configure_proxy(options, env); end

  def configure_socket(options, env); end

  def configure_ssl(options, env); end

  def configure_timeout(options, env); end

  def connection_config(env); end

  def read_body(env); end

  def request_config(env); end

  def request_options(env); end
end

module Faraday::Adapter::EMHttp::Options
end

class Faraday::Adapter::EMHttp
  def self.setup_parallel_manager(options=T.unsafe(nil)); end
end

class Faraday::Adapter::EMSynchrony
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end
end

class Faraday::Adapter::EMSynchrony::ParallelManager
  def add(request, method, *args, &block); end

  def run(); end
end

class Faraday::Adapter::EMSynchrony::ParallelManager
end

class Faraday::Adapter::EMSynchrony
  def self.setup_parallel_manager(options=T.unsafe(nil)); end
end

class Faraday::Adapter::Excon
  def create_connection(env, opts); end

  def read_body(env); end
end

class Faraday::Adapter::Excon
end

class Faraday::Adapter::HTTPClient
  def client(); end

  def configure_client(); end

  def configure_proxy(proxy); end

  def configure_socket(bind); end

  def configure_ssl(ssl); end

  def configure_timeouts(req); end

  def ssl_cert_store(ssl); end

  def ssl_verify_mode(ssl); end
end

class Faraday::Adapter::HTTPClient
end

class Faraday::Adapter::NetHttp
  NET_HTTP_EXCEPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Patron
  def configure_ssl(session, ssl); end
  CURL_TIMEOUT_MESSAGES = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Patron
end

class Faraday::Adapter::Rack
  def execute_request(env, rack_env); end

  def initialize(faraday_app, rack_app); end
  SPECIAL_HEADERS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Rack
end

class Faraday::Adapter::Test
  def configure(); end

  def initialize(app, stubs=T.unsafe(nil), &block); end

  def stubs(); end

  def stubs=(stubs); end
end

class Faraday::Adapter::Test::Stub
  def headers_match?(request_headers); end

  def initialize(host, full, headers, body, block); end

  def matches?(request_host, request_uri, request_headers, request_body); end

  def params_match?(request_params); end

  def path_match?(request_path, meta); end
end

class Faraday::Adapter::Test::Stub
end

class Faraday::Adapter::Test::Stubs
  def delete(path, headers=T.unsafe(nil), &block); end

  def empty?(); end

  def get(path, headers=T.unsafe(nil), &block); end

  def head(path, headers=T.unsafe(nil), &block); end

  def match(request_method, host, path, headers, body); end

  def matches?(stack, host, path, headers, body); end

  def new_stub(request_method, path, headers=T.unsafe(nil), body=T.unsafe(nil), &block); end

  def options(path, headers=T.unsafe(nil), &block); end

  def patch(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def post(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def put(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def verify_stubbed_calls(); end
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs
end

class Faraday::Adapter::Test
end

class Faraday::Adapter::Typhoeus
  def call(); end
end

class Faraday::Adapter::Typhoeus
end

class Faraday::Connection
  METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Env
  ContentLength = ::T.let(nil, ::T.untyped)
  MethodsWithBodies = ::T.let(nil, ::T.untyped)
  StatusesWithoutBody = ::T.let(nil, ::T.untyped)
  SuccessfulStatuses = ::T.let(nil, ::T.untyped)
end

Faraday::Error::ClientError = Faraday::ClientError

Faraday::Error::ConnectionFailed = Faraday::ConnectionFailed

Faraday::Error::ParsingError = Faraday::ParsingError

Faraday::Error::ResourceNotFound = Faraday::ResourceNotFound

Faraday::Error::RetriableResponse = Faraday::RetriableResponse

Faraday::Error::SSLError = Faraday::SSLError

Faraday::Error::TimeoutError = Faraday::TimeoutError

Faraday::Parts = Parts

class Faraday::Request::Authorization
  def call(env); end

  def initialize(app, type, token); end
  KEY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Authorization
  def self.build_hash(type, hash); end

  def self.header(type, token); end
end

class Faraday::Request::BasicAuthentication
end

class Faraday::Request::BasicAuthentication
  def self.header(login, pass); end
end

class Faraday::Request::Instrumentation
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation
end

class Faraday::Request::Multipart
  DEFAULT_BOUNDARY_PREFIX = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry
  def build_exception_matcher(exceptions); end

  def calculate_sleep_amount(retries, env); end

  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  DEFAULT_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry::Options
  DEFAULT_CHECK = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry::Options
end

class Faraday::Request::Retry
end

class Faraday::Request::TokenAuthentication
  def initialize(app, token, options=T.unsafe(nil)); end
end

class Faraday::Request::TokenAuthentication
  def self.header(token, options=T.unsafe(nil)); end
end

class Faraday::Request::UrlEncoded
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class Faraday::Response::Logger
  def debug(*args, &block); end

  def error(*args, &block); end

  def fatal(*args, &block); end

  def filter(filter_word, filter_replacement); end

  def info(*args, &block); end

  def initialize(app, logger=T.unsafe(nil), options=T.unsafe(nil)); end

  def warn(*args, &block); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Response::Logger
  extend ::Forwardable
end

class Faraday::Response::RaiseError
  ClientErrorStatuses = ::T.let(nil, ::T.untyped)
end

Faraday::Timer = Timeout

Faraday::UploadIO = UploadIO

module Faraday::Utils
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  KeyMap = ::T.let(nil, ::T.untyped)
end

class File
  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.exists?(_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.disable_stats(); end

  def self.enable_stats(); end

  def self.heap_slots(); end

  def self.heap_slots_live_after_last_gc(); end

  def self.stats_enabled?(); end

  def self.time(); end

  def self.total_malloced_bytes(); end

  def self.total_mallocs(); end

  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  UNTAINT = ::T.let(nil, ::T.untyped)
end

class Gem::Exception
  extend ::Gem::Deprecate
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Package
  def gem(); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end

  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::RemoteFetcher::FetchError
  include ::Gem::UriParsing
  def initialize(message, uri); end

  def uri(); end

  def uri=(uri); end
end

class Gem::RemoteFetcher::FetchError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def to_ruby(); end
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

Gem::Version::Requirement = Gem::Requirement

module HTTParty
  VERSION = ::T.let(nil, ::T.untyped)
end

class HTTParty::ConnectionAdapter
  OPTION_DEFAULTS = ::T.let(nil, ::T.untyped)
  StripIpv6BracketsRegex = ::T.let(nil, ::T.untyped)
end

class HTTParty::CookieHash
  CLIENT_COOKIES = ::T.let(nil, ::T.untyped)
end

class HTTParty::Logger::ApacheFormatter
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class HTTParty::Logger::CurlFormatter
  IN = ::T.let(nil, ::T.untyped)
  OUT = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class HTTParty::Logger::LogstashFormatter
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class HTTParty::Parser
  SupportedFormats = ::T.let(nil, ::T.untyped)
  UTF8_BOM = ::T.let(nil, ::T.untyped)
end

class HTTParty::Request
  JSON_API_QUERY_STRING_NORMALIZER = ::T.let(nil, ::T.untyped)
  NON_RAILS_QUERY_STRING_NORMALIZER = ::T.let(nil, ::T.untyped)
  SupportedHTTPMethods = ::T.let(nil, ::T.untyped)
  SupportedURISchemes = ::T.let(nil, ::T.untyped)
end

class HTTParty::Response
  CODES_TO_OBJ = ::T.let(nil, ::T.untyped)
end

class HTTParty::Response::Headers
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class HTTParty::ResponseFragment
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def encode_json(encoder); end
  DISALLOWED_XML_TYPES = ::T.let(nil, ::T.untyped)
  MERGER = ::T.let(nil, ::T.untyped)
end

HashWithIndifferentAccess = ActiveSupport::HashWithIndifferentAccess

class Hub
  def hub_leaders(); end

  def hub_leaders=(value); end
end

module I18n
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n::Backend
end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def exists?(locale, key); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Base
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
  USE_INSPECT_HASH = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Cache
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def exists?(locale, key); end

  def initialize(*backends); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end
end

module I18n::Backend::Chain::Implementation
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Simple::Implementation
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

class I18n::Backend::Transliterator::ProcTransliterator
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Backend
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

module I18n
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.perform_caching?(); end
end

class IO
  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def pathconf(_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
end

module JMESPath
  VERSION = ::T.let(nil, ::T.untyped)
end

class JMESPath::Lexer
  NUMBERS = ::T.let(nil, ::T.untyped)
  SIMPLE_TOKENS = ::T.let(nil, ::T.untyped)
  STATE_AND = ::T.let(nil, ::T.untyped)
  STATE_EQ = ::T.let(nil, ::T.untyped)
  STATE_GT = ::T.let(nil, ::T.untyped)
  STATE_IDENTIFIER = ::T.let(nil, ::T.untyped)
  STATE_JSON_LITERAL = ::T.let(nil, ::T.untyped)
  STATE_LBRACKET = ::T.let(nil, ::T.untyped)
  STATE_LT = ::T.let(nil, ::T.untyped)
  STATE_NOT = ::T.let(nil, ::T.untyped)
  STATE_NUMBER = ::T.let(nil, ::T.untyped)
  STATE_PIPE = ::T.let(nil, ::T.untyped)
  STATE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  STATE_SINGLE_CHAR = ::T.let(nil, ::T.untyped)
  STATE_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  STATE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TRANSLATION_TABLE = ::T.let(nil, ::T.untyped)
  T_AND = ::T.let(nil, ::T.untyped)
  T_COLON = ::T.let(nil, ::T.untyped)
  T_COMMA = ::T.let(nil, ::T.untyped)
  T_COMPARATOR = ::T.let(nil, ::T.untyped)
  T_CURRENT = ::T.let(nil, ::T.untyped)
  T_DOT = ::T.let(nil, ::T.untyped)
  T_EOF = ::T.let(nil, ::T.untyped)
  T_EXPREF = ::T.let(nil, ::T.untyped)
  T_FILTER = ::T.let(nil, ::T.untyped)
  T_FLATTEN = ::T.let(nil, ::T.untyped)
  T_IDENTIFIER = ::T.let(nil, ::T.untyped)
  T_LBRACE = ::T.let(nil, ::T.untyped)
  T_LBRACKET = ::T.let(nil, ::T.untyped)
  T_LITERAL = ::T.let(nil, ::T.untyped)
  T_LPAREN = ::T.let(nil, ::T.untyped)
  T_NOT = ::T.let(nil, ::T.untyped)
  T_NUMBER = ::T.let(nil, ::T.untyped)
  T_OR = ::T.let(nil, ::T.untyped)
  T_PIPE = ::T.let(nil, ::T.untyped)
  T_QUOTED_IDENTIFIER = ::T.let(nil, ::T.untyped)
  T_RBRACE = ::T.let(nil, ::T.untyped)
  T_RBRACKET = ::T.let(nil, ::T.untyped)
  T_RPAREN = ::T.let(nil, ::T.untyped)
  T_STAR = ::T.let(nil, ::T.untyped)
  T_UNKNOWN = ::T.let(nil, ::T.untyped)
  VALID_IDENTIFIERS = ::T.let(nil, ::T.untyped)
end

class JMESPath::Nodes::ComparatorCondition
  COMPARATOR_TO_CONDITION = ::T.let(nil, ::T.untyped)
end

class JMESPath::Nodes::Function
  FUNCTIONS = ::T.let(nil, ::T.untyped)
end

JMESPath::Nodes::Index = JMESPath::Nodes::Field

JMESPath::Nodes::Pipe = JMESPath::Nodes::Subexpression

module JMESPath::Nodes::TypeChecker
  ARRAY_TYPE = ::T.let(nil, ::T.untyped)
  BOOLEAN_TYPE = ::T.let(nil, ::T.untyped)
  EXPRESSION_TYPE = ::T.let(nil, ::T.untyped)
  NULL_TYPE = ::T.let(nil, ::T.untyped)
  NUMBER_TYPE = ::T.let(nil, ::T.untyped)
  OBJECT_TYPE = ::T.let(nil, ::T.untyped)
  STRING_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

class JMESPath::Parser
  AFTER_DOT = ::T.let(nil, ::T.untyped)
  COLON_RBRACKET = ::T.let(nil, ::T.untyped)
  CURRENT_NODE = ::T.let(nil, ::T.untyped)
  NUM_COLON_RBRACKET = ::T.let(nil, ::T.untyped)
end

JMESPath::Runtime::DEFAULT_PARSER = JMESPath::CachingParser

class JMESPath::Token
  BINDING_POWER = ::T.let(nil, ::T.untyped)
  NULL_TOKEN = ::T.let(nil, ::T.untyped)
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Kernel
  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def suppress_warnings(); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.`(_); end

  def self.at_exit(); end
end

class LoadError
  REGEXPS = ::T.let(nil, ::T.untyped)
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

class MIME::Type
  VERSION = ::T.let(nil, ::T.untyped)
end

class MIME::Types
  VERSION = ::T.let(nil, ::T.untyped)
end

module MIME::Types::Columnar
  LOAD_MUTEX = ::T.let(nil, ::T.untyped)
end

module MIME::Types::Data
  PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class MIME::Types
  extend ::Enumerable
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

MissingSourceFile = LoadError

class MobilizeAmericaRequest
  include ::HTTParty::ModuleInheritableAttributes
end

class MobilizeAmericaRequest
  def self.default_cookies(); end

  def self.default_cookies=(default_cookies); end

  def self.default_options=(default_options); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module MultiJson
  ALIASES = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

MultiJson::DecodeError = MultiJson::ParseError

MultiJson::LoadError = MultiJson::ParseError

module MultiJson::OptionsCache
  MAX_CACHE_SIZE = ::T.let(nil, ::T.untyped)
end

class MultiJson::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
end

module MultiXml
  CONTENT_ROOT = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DISALLOWED_XML_TYPES = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module Mustermann
  DEFAULT_TYPE = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Boundaries::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Expander::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::ParamScanner::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Pattern
  extend ::SingleForwardable
end

class Mustermann::AST::TemplateGenerator::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::ArrayTransform
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::ExpressionTransform
  OPERATORS = ::T.let(nil, ::T.untyped)
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::GroupTransformer
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::RootTransformer
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Translator::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Validation::NodeTranslator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mustermann::Caster
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTP::Persistent
  DEFAULT_POOL_SIZE = ::T.let(nil, ::T.untyped)
  EPOCH = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  RETRIED_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPInformation
end

Net::HTTPInformationCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def encode_json(encoder); end
end

class Numeric
  def encode_json(encoder); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  def as_json(options=T.unsafe(nil)); end

  def dclone(); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  PAGE = ::T.let(nil, ::T.untyped)
  PASS = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
  USER = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def add_certificate(*_); end

  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def >>(_); end

  def clone(); end
end

class Pry
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  CLIPPED_PRINT = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  DEFAULT_CONTROL_D_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_EXCEPTION_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_EXCEPTION_WHITELIST = ::T.let(nil, ::T.untyped)
  DEFAULT_HOOKS = ::T.let(nil, ::T.untyped)
  DEFAULT_PRINT = ::T.let(nil, ::T.untyped)
  DEFAULT_SYSTEM = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HOME_RC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  SIMPLE_PRINT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::Pry = Pry

class Pry::Code
  extend ::MethodSource::CodeHelpers
end

class Pry::CodeFile
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::ColorPrinter
  OBJ_COLOR = ::T.let(nil, ::T.untyped)
end

class Pry::Command
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::GemSearch
  API_ENDPOINT = ::T.let(nil, ::T.untyped)
end

class Pry::Command::GemStat
  FAIL_WHALE = ::T.let(nil, ::T.untyped)
  STAT_HOST = ::T.let(nil, ::T.untyped)
  STAT_PATH = ::T.let(nil, ::T.untyped)
  STAT_PORT = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Behavior
  ASSIGNMENT = ::T.let(nil, ::T.untyped)
  INSPECT_REGEXP = ::T.let(nil, ::T.untyped)
  NODUP = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Convenience
  SHORTCUTS = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Memoization
  MEMOIZED_METHODS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  COLORS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::PluginManager
  PRY_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

module Pry::Prompt
  DEFAULT_NAME = ::T.let(nil, ::T.untyped)
  SAFE_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Pry::Slop
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

class REXML::AttlistDecl
  def initialize(source); end
end

class REXML::Attribute
  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Attributes
  def initialize(element); end
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Child
  def initialize(parent=T.unsafe(nil)); end
end

class REXML::Comment
  def initialize(first, second=T.unsafe(nil)); end
end

class REXML::Declaration
  def initialize(src); end
end

class REXML::DocType
  def initialize(first, parent=T.unsafe(nil)); end
end

class REXML::Document
  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Element
  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Elements
  def initialize(parent); end
end

class REXML::Entity
  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end
end

class REXML::ExternalEntity
  def initialize(src); end
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end
end

class REXML::Formatters::Pretty
  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::Instruction
  def initialize(target, content=T.unsafe(nil)); end
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end
end

class REXML::Output
  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::ParseException
  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end
end

class REXML::Parsers::BaseParser
  def initialize(source); end
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::StreamParser
  def initialize(source, listener); end
end

class REXML::Parsers::TreeParser
  def initialize(source, build_context=T.unsafe(nil)); end
end

class REXML::Parsers::XPathParser
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
end

class REXML::Source
  def initialize(arg, encoding=T.unsafe(nil)); end
end

class REXML::SyncEnumerator
  def initialize(*enums); end
end

class REXML::Text
  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::XMLDecl
  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end
end

class REXML::XPath
  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end
end

class REXML::XPathNode
  def context(); end

  def initialize(node, context=T.unsafe(nil)); end

  def position(); end

  def raw_node(); end
end

class REXML::XPathNode
end

class REXML::XPathParser
  def initialize(strict: T.unsafe(nil)); end
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  EXPIRES = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_PORT = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Builder
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked::Body
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE_FOOTER = ::T.let(nil, ::T.untyped)
  DIR_PAGE_HEADER = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

Rack::File = Rack::Files

class Rack::Files
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, **options); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, **options); end

  def self.shutdown(); end

  def self.valid_options(); end
end

class Rack::Lint::HijackWrapper
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::Parser
  BOUNDARY_REGEX = ::T.let(nil, ::T.untyped)
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(filepath=T.unsafe(nil), ct=T.unsafe(nil), bin=T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Protection
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::AuthenticityToken
  def mask_authenticity_token(session); end
  TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::AuthenticityToken
  def self.random_token(); end

  def self.token(session); end
end

class Rack::Protection::Base
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::ContentSecurityPolicy
  def csp_policy(); end
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  NO_ARG_DIRECTIVES = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::ContentSecurityPolicy
end

class Rack::Protection::CookieTossing
  def bad_cookies(); end

  def cookie_paths(path); end

  def empty_cookie(host, path); end

  def redirect(env); end

  def remove_bad_cookies(request, response); end

  def session_key(); end
end

class Rack::Protection::CookieTossing
end

class Rack::Protection::EscapedParams
  def escape(object); end

  def escape_hash(hash); end

  def escape_string(str); end

  def handle(hash); end

  def initialize(*_); end
end

class Rack::Protection::EscapedParams
  extend ::Rack::Utils
end

class Rack::Protection::FormToken
end

class Rack::Protection::FormToken
end

class Rack::Protection::HttpOrigin
  def base_url(env); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::HttpOrigin
end

class Rack::Protection::IPSpoofing
end

class Rack::Protection::IPSpoofing
end

class Rack::Protection::JsonCsrf
  def close_body(body); end

  def has_vector?(request, headers); end

  def react_and_close(env, body); end
end

class Rack::Protection::JsonCsrf
end

class Rack::Protection::PathTraversal
  def cleanup(path); end
end

class Rack::Protection::PathTraversal
end

class Rack::Protection::RemoteReferrer
end

class Rack::Protection::RemoteReferrer
end

class Rack::Protection::RemoteToken
end

class Rack::Protection::RemoteToken
end

class Rack::Protection::SessionHijacking
end

class Rack::Protection::SessionHijacking
end

class Rack::Protection::StrictTransport
  def strict_transport(); end
end

class Rack::Protection::StrictTransport
end

class Rack::Protection::XSSHeader
end

class Rack::Protection::XSSHeader
end

class Rack::QueryParser
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::Request
  ALLOWED_SCHEMES = ::T.let(nil, ::T.untyped)
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

class Rack::Response
  CHUNKED = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::Persisted
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Cookie::SessionId
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::SessionId
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

class Random
  def self.bytes(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
  RANGE_FORMATS = ::T.let(nil, ::T.untyped)
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

class RubyVM::AbstractSyntaxTree::Node
  def pretty_print_children(q, names=T.unsafe(nil)); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end
end

ScanError = StringScanner::Error

module Seahorse::Client::H2
  DNS_ERROR_MESSAGES = ::T.let(nil, ::T.untyped)
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::H2::Connection
  CHUNKSIZE = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  SOCKET_FAMILY = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::HandlerListEntry
  STEPS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::NetHttp::ConnectionPool
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::NetHttp::ConnectionPool::ExtendedSession
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::NetHttp::Handler
  DNS_ERROR_MESSAGES = ::T.let(nil, ::T.untyped)
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::Response
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Sinatra
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sinatra::Base
  URI_INSTANCE = ::T.let(nil, ::T.untyped)
end

module Sinatra::Helpers
  ETAG_KINDS = ::T.let(nil, ::T.untyped)
end

class Sinatra::Request
  HEADER_PARAM = ::T.let(nil, ::T.untyped)
  HEADER_VALUE_WITH_PARAMS = ::T.let(nil, ::T.untyped)
end

class Sinatra::Response
  DROP_BODY_RESPONSES = ::T.let(nil, ::T.untyped)
end

class Sinatra::ShowExceptions
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def encode_json(encoder); end

  def parse_csv(**options); end

  def shellescape(); end

  def shellsplit(); end
  NON_WHITESPACE_REGEXP = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def bol?(); end

  def initialize(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def filter(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

module TZInfo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tempfile
  def _close(); end

  def inspect(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

module Tilt
  LOCK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tilt::CSVTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::CSVTemplate
  def self.engine(); end
end

class Tilt::ERBTemplate
  def precompiled(locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  SUPPORTS_KVARGS = ::T.let(nil, ::T.untyped)
end

class Tilt::ERBTemplate
  def self.default_output_variable(); end

  def self.default_output_variable=(name); end
end

class Tilt::EtanniTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::EtanniTemplate
end

class Tilt::Mapping
  AUTOLOAD_IS_BROKEN = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
end

class Tilt::PlainTemplate
end

class Tilt::PlainTemplate
end

class Tilt::RDocTemplate
  def allows_script?(); end

  def markup(); end
end

class Tilt::RDocTemplate
end

class Tilt::SigilTemplate
  def allows_script?(); end
end

class Tilt::SigilTemplate
end

class Tilt::StringTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::StringTemplate
end

Tilt::TOPOBJECT = Tilt::CompiledTemplates

class Time
  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
  DAYS_INTO_WEEK = ::T.let(nil, ::T.untyped)
end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  def encode_json(encoder); end
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

WEBrick::HTTPAuth::Authenticator::AuthException = WEBrick::HTTPStatus::Unauthorized

WEBrick::HTTPAuth::ProxyAuthenticator::AuthException = WEBrick::HTTPStatus::ProxyAuthenticationRequired

class WEBrick::HTTPRequest
  def body_reader(); end

  def readpartial(size, buf=T.unsafe(nil)); end
  MAX_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
end

class WEBrick::HTTPResponse
  def _rack_setup_header(); end

  def rack(); end

  def rack=(rack); end
end

class WEBrick::HTTPResponse::ChunkedWrapper
  def <<(*buf); end

  def initialize(socket, resp); end

  def write(buf); end
end

class WEBrick::HTTPResponse::ChunkedWrapper
end

class WEBrick::HTTPServer
  def create_request(with_webrick_config); end

  def create_response(with_webrick_config); end
end

class WEBrick::HTTPServlet::DefaultFileHandler
  def multipart_body(body, parts, boundary, mtype, filesize); end
end

module Warning
  extend ::Warning
end

class Zlib::Deflate
  def initialize(*_); end
end

class Zlib::GzipReader
  def initialize(*_); end
end

class Zlib::GzipWriter
  def initialize(*_); end
end

class Zlib::Inflate
  def initialize(*_); end
end
