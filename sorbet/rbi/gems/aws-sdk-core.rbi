# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/aws-sdk-core/all/aws-sdk-core.rbi
#
# aws-sdk-core-3.81.0

module Seahorse
end
module Seahorse::Util
  def self.uri_escape(string); end
  def self.uri_path_escape(path); end
end
module Seahorse::Client
end
class Seahorse::Client::BlockIO
  def initialize(&block); end
  def read(bytes = nil, output_buffer = nil); end
  def size; end
  def write(chunk); end
end
class Seahorse::Client::Configuration
  def add_option(name, default = nil, &block); end
  def apply_defaults(struct, options); end
  def apply_options(struct, options); end
  def build!(options = nil); end
  def empty_struct; end
  def initialize; end
end
class Seahorse::Client::Configuration::Defaults < Array
  def each(&block); end
end
class Seahorse::Client::Configuration::DynamicDefault
  def block; end
  def block=(arg0); end
  def call(*args); end
  def initialize(block = nil); end
end
class Seahorse::Client::Configuration::DefaultResolver
  def initialize(struct); end
  def method_missing(method_name, *args); end
  def resolve; end
  def resolve_defaults(opt_name, defaults); end
  def respond_to?(method_name, *args); end
  def value_at(opt_name); end
end
class Seahorse::Client::Handler
  def call(context); end
  def handler; end
  def handler=(arg0); end
  def initialize(handler = nil); end
  def inspect; end
end
module Seahorse::Client::HandlerBuilder
  def handle(*args, &block); end
  def handle_request(*args, &block); end
  def handle_response(*args, &block); end
  def handler(*args, &block); end
  def handler_for(name = nil, &block); end
  def new_handler(block); end
end
class Seahorse::Client::HandlerList
  def add(handler_class, options = nil); end
  def add_entries(entries); end
  def add_entry(entry); end
  def copy_from(source_list, &block); end
  def each(&block); end
  def entries; end
  def filter(operation); end
  def for(operation); end
  def initialize(options = nil); end
  def next_index; end
  def remove(handler_class); end
  def to_stack; end
  include Enumerable
end
class Seahorse::Client::HandlerListEntry
  def <=>(other); end
  def compute_weight; end
  def copy(options = nil); end
  def handler_class; end
  def initialize(options); end
  def inserted; end
  def operations; end
  def option(name, options); end
  def priority; end
  def set_priority(priority); end
  def set_step(step); end
  def step; end
  def weight; end
end
class Seahorse::Client::ManagedFile < File
  def open?; end
end
class Seahorse::Client::NetworkingError < StandardError
  def initialize(error, msg = nil); end
  def original_error; end
end
class Seahorse::Client::Http2InitialRequestError < StandardError
  def initialize(error); end
  def original_error; end
end
class Seahorse::Client::Http2StreamInitializeError < StandardError
  def initialize(error); end
  def original_error; end
end
class Seahorse::Client::Http2ConnectionClosedError < StandardError
end
class Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
  def add_options(config); end
  def after_initialize(client); end
  def before_initialize(client_class, options); end
  def self.after_initialize(&block); end
  def self.after_initialize_hooks; end
  def self.before_initialize(&block); end
  def self.before_initialize_hooks; end
  def self.handlers; end
  def self.literal(string); end
  def self.option(name, default = nil, options = nil, &block); end
  def self.options; end
  extend Seahorse::Client::HandlerBuilder
end
class InvalidName___Class_0x00___CodeLiteral_7 < String
  def inspect; end
end
class Seahorse::Client::Plugin::PluginOption
  def default; end
  def default=(arg0); end
  def default_block; end
  def default_block=(arg0); end
  def doc_default; end
  def doc_default=(arg0); end
  def doc_type; end
  def doc_type=(arg0); end
  def docstring; end
  def docstring=(arg0); end
  def documented?; end
  def initialize(name, options = nil); end
  def name; end
  def required; end
  def required=(arg0); end
end
class Seahorse::Client::PluginList
  def _add(plugin); end
  def add(plugin); end
  def each(&block); end
  def each_plugin(&block); end
  def initialize(plugins = nil, options = nil); end
  def remove(plugin); end
  def set(plugins); end
  include Enumerable
end
class Seahorse::Client::PluginList::PluginWrapper
  def canonical_name; end
  def eql?(other); end
  def hash; end
  def initialize(plugin); end
  def plugin; end
  def require_plugin; end
  def self.new(plugin); end
end
class Seahorse::Client::Request
  def context; end
  def handlers; end
  def initialize(handlers, context); end
  def send_request(options = nil, &block); end
  include Seahorse::Client::HandlerBuilder
end
class Seahorse::Client::RequestContext
  def [](key); end
  def []=(key, value); end
  def authorizer; end
  def authorizer=(arg0); end
  def client; end
  def client=(arg0); end
  def config; end
  def config=(arg0); end
  def http_request; end
  def http_request=(arg0); end
  def http_response; end
  def http_response=(arg0); end
  def initialize(options = nil); end
  def metadata; end
  def operation; end
  def operation=(arg0); end
  def operation_name; end
  def operation_name=(arg0); end
  def params; end
  def params=(arg0); end
  def retries; end
  def retries=(arg0); end
end
class Seahorse::Client::Response < Delegator
  def __getobj__; end
  def __setobj__(obj); end
  def context; end
  def data; end
  def data=(arg0); end
  def error; end
  def error=(arg0); end
  def initialize(options = nil); end
  def on(range, &block); end
  def on_complete(&block); end
  def on_success(&block); end
  def successful?; end
end
class Seahorse::Client::AsyncResponse
  def context; end
  def error; end
  def initialize(options = nil); end
  def join!; end
  def on(range, &block); end
  def on_complete(&block); end
  def wait; end
end
module Seahorse::Client::Http
end
class Seahorse::Client::Http::Headers
  def [](key); end
  def []=(key, value); end
  def clear; end
  def delete(key); end
  def each(&block); end
  def each_pair(&block); end
  def has_key?(key); end
  def include?(key); end
  def initialize(headers = nil); end
  def inspect; end
  def key?(key); end
  def keys; end
  def to_h; end
  def to_hash; end
  def update(headers); end
  def values; end
  def values_at(*keys); end
  include Enumerable
end
class Seahorse::Client::Http::Request
  def body; end
  def body=(io); end
  def body_contents; end
  def endpoint; end
  def endpoint=(endpoint); end
  def headers; end
  def headers=(arg0); end
  def http_method; end
  def http_method=(arg0); end
  def initialize(options = nil); end
end
class Seahorse::Client::Http::Response
  def body; end
  def body=(io); end
  def body_contents; end
  def emit(event_name, *args); end
  def error; end
  def headers; end
  def headers=(arg0); end
  def initialize(options = nil); end
  def listener(range, callback); end
  def on_data(&callback); end
  def on_done(status_code_range = nil, &callback); end
  def on_error(&callback); end
  def on_headers(status_code_range = nil, &block); end
  def on_success(status_code_range = nil, &callback); end
  def reset; end
  def signal_data(chunk); end
  def signal_done(options = nil); end
  def signal_error(networking_error); end
  def signal_headers(status_code, headers); end
  def status_code; end
  def status_code=(arg0); end
end
class Seahorse::Client::Http::AsyncResponse < Seahorse::Client::Http::Response
  def initialize(options = nil); end
  def signal_done(options = nil); end
  def signal_headers(headers); end
end
module Seahorse::Client::Logging
end
class Seahorse::Client::Logging::Handler < Seahorse::Client::Handler
  def call(context); end
  def format(config, response); end
  def log(config, response); end
end
class Seahorse::Client::Logging::Formatter
  def ==(other); end
  def _client_class(response); end
  def _error_class(response); end
  def _error_message(response); end
  def _http_request_body(response); end
  def _http_request_endpoint(response); end
  def _http_request_headers(response); end
  def _http_request_host(response); end
  def _http_request_method(response); end
  def _http_request_port(response); end
  def _http_request_scheme(response); end
  def _http_response_body(response); end
  def _http_response_headers(response); end
  def _http_response_status_code(response); end
  def _operation(response); end
  def _request_params(response); end
  def _retries(response); end
  def _time(response); end
  def eql?(other); end
  def format(response); end
  def initialize(pattern, options = nil); end
  def max_string_size; end
  def method_missing(method_name, *args); end
  def pattern; end
  def self.colored; end
  def self.default; end
  def self.short; end
  def summarize_array(array); end
  def summarize_file(path); end
  def summarize_hash(hash); end
  def summarize_string(str); end
  def summarize_string_hash(hash); end
  def summarize_symbol_hash(hash); end
  def summarize_value(value); end
end
module Seahorse::Client::NetHttp
end
module Seahorse::Client::NetHttp::Patches
  def self.apply!; end
end
module Seahorse::Client::NetHttp::Patches::Ruby_2
  def new_transport_request(req); end
end
module Seahorse::Client::NetHttp::Patches::Ruby_1_9_3
  def new_transport_request(req); end
end
class Seahorse::Client::NetHttp::ConnectionPool
  def _clean; end
  def clean!; end
  def empty!; end
  def http_continue_timeout; end
  def http_idle_timeout; end
  def http_open_timeout; end
  def http_proxy; end
  def http_proxy_parts; end
  def http_read_timeout; end
  def http_wire_trace; end
  def http_wire_trace?; end
  def initialize(options = nil); end
  def logger; end
  def remove_path_and_query(endpoint); end
  def request(endpoint, request, &block); end
  def self.for(options = nil); end
  def self.pool_options(options); end
  def self.pools; end
  def session_for(endpoint, &block); end
  def size; end
  def ssl_ca_bundle; end
  def ssl_ca_directory; end
  def ssl_ca_store; end
  def ssl_verify_peer; end
  def ssl_verify_peer?; end
  def start_session(endpoint); end
end
class Seahorse::Client::NetHttp::ConnectionPool::ExtendedSession < Delegator
  def __getobj__; end
  def __setobj__(obj); end
  def finish; end
  def initialize(http); end
  def last_used; end
  def request(*args, &block); end
end
class Seahorse::Client::NetHttp::Handler < Seahorse::Client::Handler
  def build_net_request(request); end
  def call(context); end
  def complete_response(req, resp, bytes_received); end
  def error_message(req, error); end
  def extract_headers(response); end
  def headers(request); end
  def net_http_request_class(request); end
  def pool_for(config); end
  def pool_options(config); end
  def session(config, req, &block); end
  def should_verify_bytes?(req, resp); end
  def transmit(config, req, resp); end
  def verify_bytes_received(resp, bytes_received); end
end
class Seahorse::Client::NetHttp::Handler::TruncatedBodyError < IOError
  def initialize(bytes_expected, bytes_received); end
end
class Seahorse::Client::NetHttp::Handler::InvalidHttpVerbError < StandardError
end
module Seahorse::Client::H2
end
class Seahorse::Client::H2::Connection
  def _debug_entry(str); end
  def _default_ca_bundle; end
  def _default_ca_directory; end
  def _nonblocking_connect(tcp, addr); end
  def _register_h2_callbacks; end
  def _tcp_socket(endpoint); end
  def _tls_context; end
  def close!; end
  def closed?; end
  def connect(endpoint); end
  def connection_read_timeout; end
  def connection_timeout; end
  def debug_output(msg, type = nil); end
  def enable_alpn; end
  def errors; end
  def http_wire_trace; end
  def initialize(options = nil); end
  def input_signal_thread; end
  def input_signal_thread=(arg0); end
  def logger; end
  def max_concurrent_streams; end
  def new_stream; end
  def ssl_ca_bundle; end
  def ssl_ca_directory; end
  def ssl_ca_store; end
  def ssl_verify_peer; end
  def ssl_verify_peer?; end
  def start(stream); end
end
class Seahorse::Client::H2::Handler < Seahorse::Client::Handler
  def _h2_headers(req); end
  def _register_callbacks(resp, stream, stream_mutex, close_condition, sync_queue); end
  def _send_initial_data(req, stream); end
  def _send_initial_headers(req, stream); end
  def call(context); end
  def error_message(req, error); end
end
module Seahorse::Client::Plugins
end
class Seahorse::Client::Plugins::ContentLength < Seahorse::Client::Plugin
end
class Seahorse::Client::Plugins::ContentLength::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Seahorse::Client::Plugins::Endpoint < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
  def after_initialize(client); end
end
class Seahorse::Client::Plugins::Endpoint::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Seahorse::Client::Plugins::Logging < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Seahorse::Client::Plugins::NetHttp < Seahorse::Client::Plugin
end
class Seahorse::Client::Plugins::H2 < Seahorse::Client::Plugin
end
class Seahorse::Client::Plugins::RaiseResponseErrors < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Seahorse::Client::Plugins::RaiseResponseErrors::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Seahorse::Client::Plugins::ResponseTarget < Seahorse::Client::Plugin
end
class Seahorse::Client::Plugins::ResponseTarget::Handler < Seahorse::Client::Handler
  def add_event_listeners(context, target); end
  def call(context); end
  def io(target); end
end
module Seahorse::Model
end
class Seahorse::Model::Api
  def add_authorizer(name, authorizer); end
  def add_operation(name, operation); end
  def async_operation_names; end
  def authorizer(name); end
  def authorizer_names; end
  def authorizers(&block); end
  def endpoint_operation; end
  def endpoint_operation=(arg0); end
  def initialize; end
  def inspect(*args); end
  def metadata; end
  def metadata=(arg0); end
  def operation(name); end
  def operation_names; end
  def operations(&block); end
  def version; end
  def version=(arg0); end
end
class Seahorse::Model::Operation
  def [](key); end
  def []=(key, value); end
  def async; end
  def async=(arg0); end
  def authorizer; end
  def authorizer=(arg0); end
  def deprecated; end
  def deprecated=(arg0); end
  def documentation; end
  def documentation=(arg0); end
  def endpoint_discovery; end
  def endpoint_discovery=(arg0); end
  def endpoint_operation; end
  def endpoint_operation=(arg0); end
  def endpoint_pattern; end
  def endpoint_pattern=(arg0); end
  def errors; end
  def errors=(arg0); end
  def http_method; end
  def http_method=(arg0); end
  def http_request_uri; end
  def http_request_uri=(arg0); end
  def initialize; end
  def input; end
  def input=(arg0); end
  def name; end
  def name=(arg0); end
  def output; end
  def output=(arg0); end
  def require_apikey; end
  def require_apikey=(arg0); end
end
class Seahorse::Model::Authorizer
  def initialize; end
  def name; end
  def name=(arg0); end
  def placement; end
  def placement=(arg0); end
  def type; end
  def type=(arg0); end
end
module Seahorse::Model::Shapes
end
class Seahorse::Model::Shapes::ShapeRef
  def [](key); end
  def []=(key, value); end
  def deprecated; end
  def deprecated=(arg0); end
  def documentation; end
  def documentation=(arg0); end
  def event; end
  def event=(arg0); end
  def eventheader; end
  def eventheader=(arg0); end
  def eventheader_type; end
  def eventheader_type=(arg0); end
  def eventpayload; end
  def eventpayload=(arg0); end
  def eventpayload_type; end
  def eventpayload_type=(arg0); end
  def eventstream; end
  def eventstream=(arg0); end
  def initialize(options = nil); end
  def location; end
  def location=(location); end
  def location_name; end
  def location_name=(location_name); end
  def required; end
  def required=(arg0); end
  def shape; end
  def shape=(arg0); end
end
class Seahorse::Model::Shapes::Shape
  def [](key); end
  def []=(key, value); end
  def documentation; end
  def documentation=(arg0); end
  def initialize(options = nil); end
  def name; end
  def name=(arg0); end
end
class Seahorse::Model::Shapes::BlobShape < Seahorse::Model::Shapes::Shape
  def max; end
  def max=(arg0); end
  def min; end
  def min=(arg0); end
end
class Seahorse::Model::Shapes::BooleanShape < Seahorse::Model::Shapes::Shape
end
class Seahorse::Model::Shapes::FloatShape < Seahorse::Model::Shapes::Shape
  def max; end
  def max=(arg0); end
  def min; end
  def min=(arg0); end
end
class Seahorse::Model::Shapes::IntegerShape < Seahorse::Model::Shapes::Shape
  def max; end
  def max=(arg0); end
  def min; end
  def min=(arg0); end
end
class Seahorse::Model::Shapes::ListShape < Seahorse::Model::Shapes::Shape
  def flattened; end
  def flattened=(arg0); end
  def max; end
  def max=(arg0); end
  def member; end
  def member=(arg0); end
  def min; end
  def min=(arg0); end
end
class Seahorse::Model::Shapes::MapShape < Seahorse::Model::Shapes::Shape
  def flattened; end
  def flattened=(arg0); end
  def key; end
  def key=(arg0); end
  def max; end
  def max=(arg0); end
  def min; end
  def min=(arg0); end
  def value; end
  def value=(arg0); end
end
class Seahorse::Model::Shapes::StringShape < Seahorse::Model::Shapes::Shape
  def enum; end
  def enum=(arg0); end
  def max; end
  def max=(arg0); end
  def min; end
  def min=(arg0); end
end
class Seahorse::Model::Shapes::StructureShape < Seahorse::Model::Shapes::Shape
  def add_member(name, shape_ref); end
  def initialize(options = nil); end
  def member(name); end
  def member?(member_name); end
  def member_by_location_name(location_name); end
  def member_names; end
  def members; end
  def required; end
  def required=(arg0); end
  def struct_class; end
  def struct_class=(arg0); end
end
class Seahorse::Model::Shapes::TimestampShape < Seahorse::Model::Shapes::Shape
end
class Seahorse::Client::Base
  def after_initialize(plugins); end
  def build_config(plugins, options); end
  def build_handler_list(plugins); end
  def build_request(operation_name, params = nil); end
  def config; end
  def context_for(operation_name, params); end
  def handlers; end
  def initialize(plugins, options); end
  def inspect; end
  def operation_names; end
  def self.add_plugin(plugin); end
  def self.api; end
  def self.before_initialize(plugins, options); end
  def self.build_plugins; end
  def self.clear_plugins; end
  def self.define(options = nil); end
  def self.define_operation_methods; end
  def self.extend(options = nil); end
  def self.inherited(subclass); end
  def self.new(options = nil); end
  def self.plugins; end
  def self.remove_plugin(plugin); end
  def self.set_api(api); end
  def self.set_plugins(plugins); end
  include Seahorse::Client::HandlerBuilder
end
class Seahorse::Client::AsyncBase < Seahorse::Client::Base
  def close_connection; end
  def connection; end
  def connection_errors; end
  def initialize(plugins, options); end
  def new_connection; end
  def operation_names; end
end
module Aws
  def self.config; end
  def self.config=(config); end
  def self.eager_autoload!(*args); end
  def self.empty_connection_pools!; end
  def self.partition(partition_name); end
  def self.partitions; end
  def self.shared_config; end
  def self.use_bundled_cert!; end
end
module Aws::Deprecations
  def deprecated(method, options = nil); end
end
module Aws::CredentialProvider
  def credentials; end
  def set?; end
end
module Aws::RefreshingCredentials
  def credentials; end
  def expiration; end
  def initialize(options = nil); end
  def near_expiration?; end
  def refresh!; end
  def refresh_if_near_expiration; end
end
class Aws::AssumeRoleCredentials
  def client; end
  def initialize(options = nil); end
  def refresh; end
  def self.assume_role_options; end
  include Aws::CredentialProvider
  include Aws::RefreshingCredentials
end
class Aws::AssumeRoleWebIdentityCredentials
  def _session_name; end
  def _token_from_file(path); end
  def client; end
  def initialize(options = nil); end
  def refresh; end
  def self.assume_role_web_identity_options; end
  include Aws::CredentialProvider
  include Aws::RefreshingCredentials
end
class Aws::Credentials
  def access_key_id; end
  def credentials; end
  def initialize(access_key_id, secret_access_key, session_token = nil); end
  def inspect; end
  def secret_access_key; end
  def session_token; end
  def set?; end
end
class Aws::CredentialProviderChain
  def assume_role_credentials(options); end
  def assume_role_web_identity_credentials(options); end
  def assume_role_with_profile(options); end
  def determine_profile_name(options); end
  def env_credentials(options); end
  def envar(keys); end
  def initialize(config = nil); end
  def instance_profile_credentials(options); end
  def process_credentials(options); end
  def providers; end
  def resolve; end
  def shared_credentials(options); end
  def static_credentials(options); end
end
class Aws::ECSCredentials
  def backoff(backoff); end
  def get_credentials; end
  def http_get(connection, path); end
  def initialize(options = nil); end
  def open_connection; end
  def refresh; end
  def retries; end
  def retry_errors(error_classes, options = nil, &block); end
  include Aws::CredentialProvider
  include Aws::RefreshingCredentials
end
class Aws::ECSCredentials::Non200Response < RuntimeError
end
class Aws::InstanceProfileCredentials
  def _metadata_disabled?; end
  def backoff(backoff); end
  def get_credentials; end
  def http_get(connection, path, token = nil); end
  def http_put(connection, path, ttl); end
  def initialize(options = nil); end
  def open_connection; end
  def refresh; end
  def retries; end
  def retry_errors(error_classes, options = nil, &block); end
  def token_set?; end
  include Aws::CredentialProvider
  include Aws::RefreshingCredentials
end
class Aws::InstanceProfileCredentials::Non200Response < RuntimeError
end
class Aws::InstanceProfileCredentials::TokenRetrivalError < RuntimeError
end
class Aws::InstanceProfileCredentials::TokenExpiredError < RuntimeError
end
class Aws::InstanceProfileCredentials::Token
  def expired?; end
  def initialize(value, ttl); end
  def value; end
end
class Aws::IniParser
  def self.ini_parse(raw); end
end
class Aws::SharedCredentials
  def credentials; end
  def initialize(options = nil); end
  def inspect; end
  def loadable?; end
  def path; end
  def profile_name; end
  include Aws::CredentialProvider
end
class Aws::ProcessCredentials
  def _parse_payload_format_v1(creds_json); end
  def credentials_from_process(proc_invocation); end
  def initialize(process); end
  def near_expiration?; end
  def refresh; end
  include Aws::CredentialProvider
  include Aws::RefreshingCredentials
end
module Aws::ClientStubs
  def api_requests(options = nil); end
  def apply_stubs(operation_name, stubs); end
  def convert_stub(operation_name, stub); end
  def data_to_http_resp(operation_name, data); end
  def default_stub(operation_name); end
  def hash_to_http_resp(data); end
  def http_response_stub(operation_name, data); end
  def next_stub(context); end
  def protocol_helper; end
  def service_error_stub(error_code); end
  def setup_stubbing; end
  def stub_data(operation_name, data = nil); end
  def stub_responses(operation_name, *stubs); end
end
module Aws::AsyncClientStubs
  def send_events; end
  def setup_stubbing; end
  include Aws::ClientStubs
end
class Aws::AsyncClientStubs::StubStream
  def close; end
  def closed?; end
  def data(bytes, options = nil); end
  def initialize; end
  def send_events; end
  def send_events=(arg0); end
  def state; end
end
class Aws::EagerLoader
  def initialize; end
  def load(klass_or_module); end
  def loaded; end
end
module Aws::Errors
end
class Aws::Errors::NonSupportedRubyVersionError < RuntimeError
end
class Aws::Errors::ServiceError < RuntimeError
  def code; end
  def context; end
  def data; end
  def initialize(context, message, data = nil); end
  def self.code; end
  def self.code=(arg0); end
end
class Aws::Errors::MetadataParserError < RuntimeError
  def initialize(*args); end
end
class Aws::Errors::MissingContentLength < RuntimeError
  def initialize(*args); end
end
class Aws::Errors::EndpointDiscoveryError < RuntimeError
  def initialize(*args); end
end
class Aws::Errors::MissingEndpointHostLabelValue < RuntimeError
  def initialize(name); end
end
class Aws::Errors::SignalEventError < RuntimeError
end
class Aws::Errors::EventStreamParserError < RuntimeError
end
class Aws::Errors::EventStreamBuilderError < RuntimeError
end
class Aws::Errors::EventError < RuntimeError
  def error_code; end
  def error_message; end
  def event_type; end
  def initialize(event_type, code, message); end
end
class Aws::Errors::ChecksumError < RuntimeError
end
class Aws::Errors::NoSuchProfileError < RuntimeError
end
class Aws::Errors::NoSourceProfileError < RuntimeError
end
class Aws::Errors::InvalidCredentialSourceError < RuntimeError
end
class Aws::Errors::CredentialSourceConflictError < RuntimeError
end
class Aws::Errors::NoSourceCredentialsError < RuntimeError
end
class Aws::Errors::MissingCredentialsError < RuntimeError
  def initialize(*args); end
end
class Aws::Errors::MissingWebIdentityTokenFile < RuntimeError
  def initialize(*args); end
end
class Aws::Errors::InvalidProcessCredentialsPayload < RuntimeError
end
class Aws::Errors::MissingRegionError < ArgumentError
  def initialize(*args); end
end
class Aws::Errors::NoSuchEndpointError < RuntimeError
  def context; end
  def endpoint; end
  def initialize(options = nil); end
  def original_error; end
  def possible_regions; end
end
module Aws::Errors::DynamicErrors
  def const_missing(constant); end
  def error_class(error_code); end
  def error_class_constant(error_code); end
  def error_const_set?(constant); end
  def self.extended(submodule); end
  def set_error_constant(constant); end
end
module Aws::PageableResponse
  def each(&block); end
  def each_page(&block); end
  def last_page?; end
  def next_page(params = nil); end
  def next_page?; end
  def next_page_params(params); end
  def next_response(params); end
  def pager; end
  def pager=(arg0); end
  def self.extended(base); end
end
class Aws::PageableResponse::LastPageError < RuntimeError
  def initialize(response); end
  def response; end
end
module Aws::PageableResponse::UnsafeEnumerableMethods
  def count; end
  def respond_to?(method_name, *args); end
  def to_h; end
end
class Aws::Pager
  def empty_value?(value); end
  def initialize(options); end
  def limit_key; end
  def next_tokens(response); end
  def prev_tokens(response); end
  def truncated?(response); end
end
class Aws::Pager::NullPager
  def limit_key; end
  def next_tokens; end
  def prev_tokens; end
  def truncated?(response); end
end
class Aws::ParamConverter
  def c(ref, value); end
  def close_opened_files; end
  def convert(params); end
  def initialize(rules); end
  def list(ref, values); end
  def map(ref, values); end
  def member(ref, value); end
  def opened_files; end
  def self.add(shape_class, value_class, converter = nil, &block); end
  def self.c(shape, value, instance = nil); end
  def self.convert(shape, params); end
  def self.converter_for(shape_class, value); end
  def self.each_base_class(shape_class, &block); end
  def self.ensure_open(file, converter); end
  def self.find(shape_class, value); end
  def structure(ref, values); end
  include Seahorse::Model::Shapes
end
class Aws::ParamValidator
  def correct_type?(ref, value, errors, context); end
  def error_messages(errors); end
  def expected_got(context, expected, got); end
  def initialize(rules, options = nil); end
  def io_like?(value); end
  def list(ref, values, errors, context); end
  def map(ref, values, errors, context); end
  def self.validate!(rules, params); end
  def shape(ref, value, errors, context); end
  def structure(ref, values, errors, context); end
  def validate!(params); end
  include Seahorse::Model::Shapes
end
class Aws::SharedConfig
  def assume_role_credentials_from_config(opts = nil); end
  def assume_role_from_profile(cfg, profile, opts, chain_config); end
  def assume_role_process_credentials_from_config(profile); end
  def assume_role_web_identity_credentials_from_config(profile); end
  def config_enabled?; end
  def config_path; end
  def credentials(opts = nil); end
  def credentials_complete(creds); end
  def credentials_from_config(profile, opts); end
  def credentials_from_profile(prof_config); end
  def credentials_from_shared(profile, opts); end
  def credentials_from_source(credential_source, config); end
  def credentials_path; end
  def credentials_present?; end
  def credentials_process(profile); end
  def csm_client_id(opts = nil); end
  def csm_enabled(opts = nil); end
  def csm_host(opts = nil); end
  def csm_port(opts = nil); end
  def default_shared_config_path(file); end
  def determine_config_path; end
  def determine_credentials_path; end
  def determine_profile(options); end
  def endpoint_discovery(opts = nil); end
  def fresh(options = nil); end
  def initialize(options = nil); end
  def load_config_file; end
  def load_credentials_file; end
  def loadable?(path); end
  def profile_name; end
  def region(opts = nil); end
  def resolve_source_profile(profile); end
  def s3_us_east_1_regional_endpoint(opts = nil); end
  def sts_regional_endpoints(opts = nil); end
  def validate_profile_exists(profile); end
end
module Aws::Structure
  def empty?; end
  def initialize(values = nil); end
  def key?(member_name); end
  def self.new(*args); end
  def to_h(obj = nil); end
  def to_hash(obj = nil); end
  def to_s(obj = nil); end
end
class Struct::AwsEmptyStructure < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::EmptyStructure < Struct::AwsEmptyStructure
  include Aws::Structure
end
class Aws::TypeBuilder
  def build_type(shape, shapes); end
  def initialize(svc_module); end
end
module Aws::Util
  def self.copy_hash(hash); end
  def self.deep_copy(obj); end
  def self.deep_merge(left, right); end
  def self.monotonic_milliseconds; end
  def self.str_2_bool(str); end
end
module Aws::Resources
end
class Aws::Resources::Collection
  def [](*args, &block); end
  def batch_enum; end
  def batches; end
  def each(&block); end
  def first(count = nil); end
  def initialize(batches, options = nil); end
  def length; end
  def limit(limit); end
  def limited_batches; end
  def non_empty_batches; end
  def size; end
  extend Aws::Deprecations
  include Enumerable
end
module Aws::Log
end
class Aws::Log::Formatter
  def _client_class(response); end
  def _error_class(response); end
  def _error_message(response); end
  def _http_request_body(response); end
  def _http_request_endpoint(response); end
  def _http_request_headers(response); end
  def _http_request_host(response); end
  def _http_request_method(response); end
  def _http_request_port(response); end
  def _http_request_scheme(response); end
  def _http_response_body(response); end
  def _http_response_headers(response); end
  def _http_response_status_code(response); end
  def _operation(response); end
  def _request_params(response); end
  def _retries(response); end
  def _time(response); end
  def format(response); end
  def initialize(pattern, options = nil); end
  def method_missing(method_name, *args); end
  def pattern; end
  def self.colored(options = nil); end
  def self.default(options = nil); end
  def self.short(options = nil); end
end
class Aws::Log::ParamFilter
  def filter(value); end
  def filter_array(values); end
  def filter_hash(values); end
  def initialize(options = nil); end
end
class Aws::Log::ParamFormatter
  def initialize(options = nil); end
  def summarize(value); end
  def summarize_array(array); end
  def summarize_file(path); end
  def summarize_hash(hash); end
  def summarize_string(str); end
  def summarize_string_hash(hash); end
  def summarize_symbol_hash(hash); end
  def summarize_value(value); end
end
module Aws::Stubbing
end
class Aws::Stubbing::EmptyStub
  def initialize(rules); end
  def stub; end
  def stub_ref(ref, visited = nil); end
  def stub_scalar(ref); end
  def stub_structure(ref, visited); end
  include Seahorse::Model::Shapes
end
class Aws::Stubbing::DataApplicator
  def apply_data(data, stub); end
  def apply_data_to_struct(ref, data, struct); end
  def initialize(rules); end
  def member_value(ref, value); end
  include Seahorse::Model::Shapes
end
class Aws::Stubbing::StubData
  def apply_data(data, stub); end
  def initialize(operation); end
  def remove_paging_tokens(stub); end
  def stub(data = nil); end
end
class Aws::Stubbing::XmlError
  def initialize(error_code); end
  def to_xml; end
end
module Aws::Stubbing::Protocols
end
class Aws::Stubbing::Protocols::EC2
  def build_body(api, operation, data); end
  def stub_data(api, operation, data); end
  def stub_error(error_code); end
end
class Aws::Stubbing::Protocols::Json
  def build_body(operation, data); end
  def content_type(api); end
  def stub_data(api, operation, data); end
  def stub_error(error_code); end
end
class Aws::Stubbing::Protocols::Query
  def build_body(api, operation, data); end
  def stub_data(api, operation, data); end
  def stub_error(error_code); end
  def xmlns(api); end
end
class Aws::Stubbing::Protocols::Rest
  def apply_body(api, operation, resp, data); end
  def apply_headers(operation, resp, data); end
  def apply_status_code(operation, resp, data); end
  def build_body(api, operation, data); end
  def encode_error(opts, event_data); end
  def encode_event(opts, rules, event_data, builder); end
  def encode_eventstream_response(rules, data, builder); end
  def eventstream?(rules); end
  def head_operation(operation); end
  def new_http_response; end
  def streaming?(ref); end
  def stub_data(api, operation, data); end
  include Seahorse::Model::Shapes
end
class Aws::Stubbing::Protocols::RestJson < Aws::Stubbing::Protocols::Rest
  def body_for(_, _, rules, data); end
  def stub_error(error_code); end
end
class Aws::Stubbing::Protocols::RestXml < Aws::Stubbing::Protocols::Rest
  def body_for(api, operation, rules, data); end
  def stub_error(error_code); end
  def xmlns(api); end
  include Seahorse::Model::Shapes
end
class Aws::Stubbing::Protocols::ApiGateway < Aws::Stubbing::Protocols::RestJson
end
module Aws::Rest
end
class Aws::Rest::Handler < Seahorse::Client::Handler
  def apply_request_id(context); end
  def call(context); end
end
module Aws::Rest::Request
end
class Aws::Rest::Request::Body
  def apply(http_req, params); end
  def body_params(params); end
  def build_body(params); end
  def initialize(serializer_class, rules); end
  def serialize(rules, params); end
  def streaming?; end
  include Seahorse::Model::Shapes
end
class Aws::Rest::Request::Builder
  def apply(context); end
  def populate_body(context); end
  def populate_endpoint(context); end
  def populate_headers(context); end
  def populate_http_method(context); end
  def serializer_class(context); end
end
class Aws::Rest::Request::Endpoint
  def apply_path_params(uri, params); end
  def apply_querystring_params(uri, params); end
  def escape(string); end
  def initialize(rules, request_uri_pattern); end
  def param_name(placeholder); end
  def param_value_for_placeholder(placeholder, params); end
  def uri(base_uri, params); end
end
class Aws::Rest::Request::Headers
  def apply(http_req, params); end
  def apply_header_map(headers, ref, values); end
  def apply_header_value(headers, ref, value); end
  def apply_json_trait(value); end
  def initialize(rules); end
  def timestamp(ref, value); end
  include Seahorse::Model::Shapes
end
class Aws::Rest::Request::QuerystringBuilder
  def build(params); end
  def build_part(shape_ref, param_value); end
  def escape(string); end
  def list_of_strings(name, values); end
  def query_map_of_string(hash); end
  def query_map_of_string_list(hash); end
  def timestamp(ref, value); end
  include Seahorse::Model::Shapes
end
module Aws::Rest::Response
end
class Aws::Rest::Response::Body
  def apply(body, data); end
  def event_stream?; end
  def initialize(parser_class, rules); end
  def parse(body, rules, target = nil); end
  def parse_eventstream(body); end
  def streaming?; end
  include Seahorse::Model::Shapes
end
class Aws::Rest::Response::Headers
  def apply(http_resp, target); end
  def cast_value(ref, value); end
  def extract_header_map(headers, name, ref, data); end
  def extract_header_value(headers, name, ref, data); end
  def extract_json_trait(value); end
  def initialize(rules); end
  include Seahorse::Model::Shapes
end
class Aws::Rest::Response::Parser
  def apply(response); end
  def extract_body(rules, response); end
  def extract_headers(rules, response); end
  def extract_status_code(rules, response); end
  def parser_class(response); end
end
class Aws::Rest::Response::StatusCode
  def apply(http_resp, data); end
  def initialize(rules); end
end
module Aws::Xml
end
class Aws::Xml::Builder
  def blob(value); end
  def initialize(rules, options = nil); end
  def list(name, ref, values); end
  def map(name, ref, hash); end
  def member(name, ref, value); end
  def node(name, ref, *args, &block); end
  def serialize(params); end
  def shape_attrs(ref); end
  def structure(name, ref, values); end
  def structure_attrs(ref, values); end
  def timestamp(ref, value); end
  def to_xml(params); end
  def xml_attribute?(ref); end
  include Seahorse::Model::Shapes
end
class Aws::Xml::DefaultList < Array
  def nil?; end
end
class Aws::Xml::DefaultMap < Hash
  def nil?; end
end
class Aws::Xml::DocBuilder
  def attributes(attr); end
  def close_el(name); end
  def empty_element(name, attrs); end
  def escape(string, text_or_attr); end
  def increase_pad(&block); end
  def initialize(options = nil); end
  def inline_element(name, value, attrs); end
  def node(name, *args, &block); end
  def open_el(name, attrs); end
  def target; end
end
class Aws::Xml::ErrorHandler < Seahorse::Client::Handler
  def call(context); end
  def error(context); end
  def error_code(body, context); end
  def error_data(context, code); end
  def error_message(body); end
  def extract_error(body, context); end
  def http_status_error_code(context); end
  def remove_prefix(error_code, context); end
  def unescape(str); end
end
class Aws::Xml::Parser
  def initialize(rules, options = nil); end
  def parse(xml, target = nil, &unhandled_callback); end
  def self.engine; end
  def self.engine=(engine); end
  def self.load_engine(name); end
  def self.set_default_engine; end
  def self.try_load_engine(name); end
  include Seahorse::Model::Shapes
end
class Aws::Xml::Parser::RexmlEngine
  def initialize(stack); end
  def parse(xml); end
  def tag_end(name); end
  def tag_start(name, attrs); end
  def text(value); end
  include REXML::StreamListener
end
class Aws::Xml::Parser::Stack
  def attr(name, value); end
  def child_frame(name); end
  def consume_child_frame(frame); end
  def end_element(*args); end
  def error(msg, line = nil, column = nil); end
  def frame; end
  def initialize(ref, result = nil, &unhandled_callback); end
  def result; end
  def start_element(name); end
  def text(value); end
  def yield_unhandled_value(path, value); end
end
class Aws::Xml::Parser::Frame
  def child_frame(xml_name); end
  def consume_child_frame(child); end
  def initialize(path, parent, ref, result); end
  def parent; end
  def path; end
  def ref; end
  def result; end
  def self.frame_class(ref); end
  def self.new(path, parent, ref, result = nil); end
  def set_text(value); end
  def yield_unhandled_value(path, value); end
  include Seahorse::Model::Shapes
end
class Aws::Xml::Parser::StructureFrame < Aws::Xml::Parser::Frame
  def apply_default_value(name, ref); end
  def child_frame(xml_name); end
  def consume_child_frame(child); end
  def flattened_list?(ref); end
  def initialize(xml_name, parent, ref, result = nil); end
  def xml_name(ref); end
end
class Aws::Xml::Parser::ListFrame < Aws::Xml::Parser::Frame
  def child_frame(xml_name); end
  def consume_child_frame(child); end
  def initialize(*args); end
end
class Aws::Xml::Parser::FlatListFrame < Aws::Xml::Parser::Frame
  def child_frame(xml_name); end
  def consume_child_frame(child); end
  def initialize(xml_name, *args); end
  def result; end
  def set_text(value); end
end
class Aws::Xml::Parser::MapFrame < Aws::Xml::Parser::Frame
  def child_frame(xml_name); end
  def consume_child_frame(child); end
  def initialize(*args); end
end
class Aws::Xml::Parser::MapEntryFrame < Aws::Xml::Parser::Frame
  def child_frame(xml_name); end
  def initialize(xml_name, *args); end
  def key; end
  def value; end
end
class Aws::Xml::Parser::NullFrame < Aws::Xml::Parser::Frame
  def self.new(xml_name, parent); end
  def set_text(value); end
end
class Aws::Xml::Parser::BlobFrame < Aws::Xml::Parser::Frame
  def result; end
end
class Aws::Xml::Parser::BooleanFrame < Aws::Xml::Parser::Frame
  def result; end
end
class Aws::Xml::Parser::FloatFrame < Aws::Xml::Parser::Frame
  def result; end
end
class Aws::Xml::Parser::IntegerFrame < Aws::Xml::Parser::Frame
  def result; end
end
class Aws::Xml::Parser::StringFrame < Aws::Xml::Parser::Frame
  def result; end
end
class Aws::Xml::Parser::TimestampFrame < Aws::Xml::Parser::Frame
  def parse(value); end
  def result; end
end
class Aws::Xml::Parser::ParsingError < RuntimeError
  def column; end
  def initialize(msg, line, column); end
  def line; end
end
module Aws::Json
  def self.dump(value); end
  def self.json_engine; end
  def self.load(json); end
  def self.load_file(path); end
  def self.oj_engine; end
  def self.oj_parse_error; end
end
class Aws::Json::Builder
  def encode(blob); end
  def format(ref, value); end
  def initialize(rules); end
  def list(ref, values); end
  def map(ref, values); end
  def serialize(params); end
  def structure(ref, values); end
  def timestamp(ref, value); end
  def to_json(params); end
  include Seahorse::Model::Shapes
end
class Aws::Json::ErrorHandler < Aws::Xml::ErrorHandler
  def call(context); end
  def error_code(json, context); end
  def error_message(code, json); end
  def extract_error(body, context); end
  def parse_error_data(context, code); end
end
class Aws::Json::Handler < Seahorse::Client::Handler
  def apply_request_id(context); end
  def build_body(context); end
  def build_request(context); end
  def call(context); end
  def content_type(context); end
  def parse_body(context); end
  def parse_response(response); end
  def simple_json?(context); end
  def target(context); end
end
class Aws::Json::Parser
  def initialize(rules); end
  def list(ref, values, target = nil); end
  def map(ref, values, target = nil); end
  def parse(json, target = nil); end
  def parse_ref(ref, value, target = nil); end
  def structure(ref, values, target = nil); end
  def time(value); end
  include Seahorse::Model::Shapes
end
class Aws::Json::ParseError < StandardError
  def error; end
  def initialize(error); end
end
module Aws::Binary
end
class Aws::Binary::DecodeHandler < Seahorse::Client::Handler
  def attach_eventstream_listeners(context, rules); end
  def call(context); end
  def eventstream?(ctx); end
end
class Aws::Binary::EncodeHandler < Seahorse::Client::Handler
  def call(context); end
  def eventstream_input?(ctx); end
end
class Aws::Binary::EventStreamDecoder
  def emit_event(raw_event); end
  def events; end
  def extract_stream_class(type_class); end
  def initialize(protocol, rules, output_ref, error_refs, io, event_stream_handler = nil); end
  def parser_class(protocol); end
  def write(chunk); end
end
class Aws::Binary::EventStreamEncoder
  def encode(event_type, params); end
  def initialize(protocol, rules, input_ref, signer); end
  def prior_signature; end
  def prior_signature=(arg0); end
  def rules; end
  def serializer_class(protocol); end
end
class Aws::Binary::EventBuilder
  def _build_payload(streaming, ref, value); end
  def _content_type(shape); end
  def _event_stream_message(event_ref, params); end
  def _header_value_type(shape, value); end
  def apply(event_type, params); end
  def initialize(serializer_class, rules); end
  include Seahorse::Model::Shapes
end
class Aws::Binary::EventParser
  def apply(raw_event); end
  def eventpayload_streaming?(ref); end
  def initialize(parser_class, rules, error_refs, output_ref); end
  def parse(raw_event); end
  def parse_error_event(raw_event); end
  def parse_event(raw_event); end
  def parse_exception(raw_event); end
  def parse_payload(body, rules); end
  include Seahorse::Model::Shapes
end
class Aws::EventEmitter
  def _ready_for_events?; end
  def emit(type, params); end
  def encoder; end
  def encoder=(arg0); end
  def initialize; end
  def on(type, callback); end
  def signal(type, event); end
  def signal_queue; end
  def signal_queue=(arg0); end
  def stream; end
  def stream=(arg0); end
  def validate_event; end
  def validate_event=(arg0); end
end
class Aws::EndpointCache
  def [](key); end
  def []=(key, value); end
  def _endpoint_operation_identifier(ctx); end
  def _request_endpoint(ctx); end
  def delete(key); end
  def delete_polling_thread(key); end
  def extract_key(ctx); end
  def initialize(options = nil); end
  def key?(key); end
  def max_entries; end
  def max_threads; end
  def pool; end
  def stop_polling!; end
  def threads_key?(key); end
  def update(key, ctx); end
  def update_polling_pool(key, thread); end
end
class Aws::EndpointCache::Endpoint
  def address; end
  def expired?; end
  def initialize(options); end
end
module Aws::ClientSideMonitoring
end
class Aws::ClientSideMonitoring::RequestMetrics
  def add_call_attempt(attempt); end
  def api_call; end
  def api_call_attempts; end
  def build_call_attempt(opts = nil); end
  def initialize(opts = nil); end
end
class Aws::ClientSideMonitoring::RequestMetrics::ApiCall
  def _truncate(document); end
  def api; end
  def attempt_count; end
  def client_id; end
  def complete(opts = nil); end
  def final_aws_exception; end
  def final_aws_exception_message; end
  def final_http_status_code; end
  def final_sdk_exception; end
  def final_sdk_exception_message; end
  def initialize(service, api, client_id, version, timestamp, region); end
  def latency; end
  def max_retries_exceeded; end
  def region; end
  def service; end
  def timestamp; end
  def to_json(*a); end
  def user_agent; end
  def version; end
end
class Aws::ClientSideMonitoring::RequestMetrics::ApiCallAttempt
  def _truncate(document); end
  def access_key; end
  def api; end
  def aws_exception; end
  def aws_exception=(arg0); end
  def aws_exception_msg; end
  def aws_exception_msg=(arg0); end
  def client_id; end
  def fqdn; end
  def fqdn=(arg0); end
  def http_status_code; end
  def http_status_code=(arg0); end
  def initialize(service, api, client_id, version, timestamp, fqdn, region, user_agent, access_key, session_token); end
  def region; end
  def region=(arg0); end
  def request_latency; end
  def request_latency=(arg0); end
  def sdk_exception; end
  def sdk_exception=(arg0); end
  def sdk_exception_msg; end
  def sdk_exception_msg=(arg0); end
  def service; end
  def session_token; end
  def timestamp; end
  def to_json(*a); end
  def user_agent; end
  def version; end
  def x_amz_id_2; end
  def x_amz_id_2=(arg0); end
  def x_amz_request_id; end
  def x_amz_request_id=(arg0); end
  def x_amzn_request_id; end
  def x_amzn_request_id=(arg0); end
end
class Aws::ClientSideMonitoring::Publisher
  def agent_host; end
  def agent_host=(value); end
  def agent_port; end
  def agent_port=(value); end
  def initialize(opts = nil); end
  def publish(request_metrics); end
  def send_datagram(msg); end
end
module Aws::STS
end
module Aws::STS::Types
end
class Anonymous_Struct_8 < Struct
  def duration_seconds; end
  def duration_seconds=(_); end
  def external_id; end
  def external_id=(_); end
  def policy; end
  def policy=(_); end
  def policy_arns; end
  def policy_arns=(_); end
  def role_arn; end
  def role_arn=(_); end
  def role_session_name; end
  def role_session_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def serial_number; end
  def serial_number=(_); end
  def tags; end
  def tags=(_); end
  def token_code; end
  def token_code=(_); end
  def transitive_tag_keys; end
  def transitive_tag_keys=(_); end
end
class Aws::STS::Types::AssumeRoleRequest < Anonymous_Struct_8
  include Aws::Structure
end
class Anonymous_Struct_9 < Struct
  def assumed_role_user; end
  def assumed_role_user=(_); end
  def credentials; end
  def credentials=(_); end
  def packed_policy_size; end
  def packed_policy_size=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::AssumeRoleResponse < Anonymous_Struct_9
  include Aws::Structure
end
class Anonymous_Struct_10 < Struct
  def duration_seconds; end
  def duration_seconds=(_); end
  def policy; end
  def policy=(_); end
  def policy_arns; end
  def policy_arns=(_); end
  def principal_arn; end
  def principal_arn=(_); end
  def role_arn; end
  def role_arn=(_); end
  def saml_assertion; end
  def saml_assertion=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::AssumeRoleWithSAMLRequest < Anonymous_Struct_10
  include Aws::Structure
end
class Anonymous_Struct_11 < Struct
  def assumed_role_user; end
  def assumed_role_user=(_); end
  def audience; end
  def audience=(_); end
  def credentials; end
  def credentials=(_); end
  def issuer; end
  def issuer=(_); end
  def name_qualifier; end
  def name_qualifier=(_); end
  def packed_policy_size; end
  def packed_policy_size=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def subject; end
  def subject=(_); end
  def subject_type; end
  def subject_type=(_); end
end
class Aws::STS::Types::AssumeRoleWithSAMLResponse < Anonymous_Struct_11
  include Aws::Structure
end
class Anonymous_Struct_12 < Struct
  def duration_seconds; end
  def duration_seconds=(_); end
  def policy; end
  def policy=(_); end
  def policy_arns; end
  def policy_arns=(_); end
  def provider_id; end
  def provider_id=(_); end
  def role_arn; end
  def role_arn=(_); end
  def role_session_name; end
  def role_session_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def web_identity_token; end
  def web_identity_token=(_); end
end
class Aws::STS::Types::AssumeRoleWithWebIdentityRequest < Anonymous_Struct_12
  include Aws::Structure
end
class Anonymous_Struct_13 < Struct
  def assumed_role_user; end
  def assumed_role_user=(_); end
  def audience; end
  def audience=(_); end
  def credentials; end
  def credentials=(_); end
  def packed_policy_size; end
  def packed_policy_size=(_); end
  def provider; end
  def provider=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def subject_from_web_identity_token; end
  def subject_from_web_identity_token=(_); end
end
class Aws::STS::Types::AssumeRoleWithWebIdentityResponse < Anonymous_Struct_13
  include Aws::Structure
end
class Anonymous_Struct_14 < Struct
  def arn; end
  def arn=(_); end
  def assumed_role_id; end
  def assumed_role_id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::AssumedRoleUser < Anonymous_Struct_14
  include Aws::Structure
end
class Anonymous_Struct_15 < Struct
  def access_key_id; end
  def access_key_id=(_); end
  def expiration; end
  def expiration=(_); end
  def secret_access_key; end
  def secret_access_key=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def session_token; end
  def session_token=(_); end
end
class Aws::STS::Types::Credentials < Anonymous_Struct_15
  include Aws::Structure
end
class Anonymous_Struct_16 < Struct
  def encoded_message; end
  def encoded_message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::DecodeAuthorizationMessageRequest < Anonymous_Struct_16
  include Aws::Structure
end
class Anonymous_Struct_17 < Struct
  def decoded_message; end
  def decoded_message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::DecodeAuthorizationMessageResponse < Anonymous_Struct_17
  include Aws::Structure
end
class Anonymous_Struct_18 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::ExpiredTokenException < Anonymous_Struct_18
  include Aws::Structure
end
class Anonymous_Struct_19 < Struct
  def arn; end
  def arn=(_); end
  def federated_user_id; end
  def federated_user_id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::FederatedUser < Anonymous_Struct_19
  include Aws::Structure
end
class Anonymous_Struct_20 < Struct
  def access_key_id; end
  def access_key_id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::GetAccessKeyInfoRequest < Anonymous_Struct_20
  include Aws::Structure
end
class Anonymous_Struct_21 < Struct
  def account; end
  def account=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::GetAccessKeyInfoResponse < Anonymous_Struct_21
  include Aws::Structure
end
class Aws::STS::Types::GetCallerIdentityRequest < Aws::EmptyStructure
end
class Anonymous_Struct_22 < Struct
  def account; end
  def account=(_); end
  def arn; end
  def arn=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def user_id; end
  def user_id=(_); end
end
class Aws::STS::Types::GetCallerIdentityResponse < Anonymous_Struct_22
  include Aws::Structure
end
class Anonymous_Struct_23 < Struct
  def duration_seconds; end
  def duration_seconds=(_); end
  def name; end
  def name=(_); end
  def policy; end
  def policy=(_); end
  def policy_arns; end
  def policy_arns=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def tags; end
  def tags=(_); end
end
class Aws::STS::Types::GetFederationTokenRequest < Anonymous_Struct_23
  include Aws::Structure
end
class Anonymous_Struct_24 < Struct
  def credentials; end
  def credentials=(_); end
  def federated_user; end
  def federated_user=(_); end
  def packed_policy_size; end
  def packed_policy_size=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::GetFederationTokenResponse < Anonymous_Struct_24
  include Aws::Structure
end
class Anonymous_Struct_25 < Struct
  def duration_seconds; end
  def duration_seconds=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def serial_number; end
  def serial_number=(_); end
  def token_code; end
  def token_code=(_); end
end
class Aws::STS::Types::GetSessionTokenRequest < Anonymous_Struct_25
  include Aws::Structure
end
class Anonymous_Struct_26 < Struct
  def credentials; end
  def credentials=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::GetSessionTokenResponse < Anonymous_Struct_26
  include Aws::Structure
end
class Anonymous_Struct_27 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::IDPCommunicationErrorException < Anonymous_Struct_27
  include Aws::Structure
end
class Anonymous_Struct_28 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::IDPRejectedClaimException < Anonymous_Struct_28
  include Aws::Structure
end
class Anonymous_Struct_29 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::InvalidAuthorizationMessageException < Anonymous_Struct_29
  include Aws::Structure
end
class Anonymous_Struct_30 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::InvalidIdentityTokenException < Anonymous_Struct_30
  include Aws::Structure
end
class Anonymous_Struct_31 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::MalformedPolicyDocumentException < Anonymous_Struct_31
  include Aws::Structure
end
class Anonymous_Struct_32 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::PackedPolicyTooLargeException < Anonymous_Struct_32
  include Aws::Structure
end
class Anonymous_Struct_33 < Struct
  def arn; end
  def arn=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::PolicyDescriptorType < Anonymous_Struct_33
  include Aws::Structure
end
class Anonymous_Struct_34 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::RegionDisabledException < Anonymous_Struct_34
  include Aws::Structure
end
class Anonymous_Struct_35 < Struct
  def key; end
  def key=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def value; end
  def value=(_); end
end
class Aws::STS::Types::Tag < Anonymous_Struct_35
  include Aws::Structure
end
module Aws::STS::ClientApi
  include Seahorse::Model
end
module Aws::Plugins
end
class Aws::Plugins::CredentialsConfiguration < Seahorse::Client::Plugin
end
class Aws::Plugins::Logging < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Aws::Plugins::Logging::Handler < Seahorse::Client::Handler
  def call(context); end
  def format(config, response); end
  def log(config, response); end
end
class Aws::Plugins::ParamConverter < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Aws::Plugins::ParamConverter::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::ParamValidator < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Aws::Plugins::ParamValidator::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::UserAgent < Seahorse::Client::Plugin
end
class Aws::Plugins::UserAgent::Handler < Seahorse::Client::Handler
  def call(context); end
  def set_user_agent(context); end
end
class Aws::Plugins::HelpfulSocketErrors < Seahorse::Client::Plugin
end
class Aws::Plugins::HelpfulSocketErrors::Handler < Seahorse::Client::Handler
  def call(context); end
  def no_such_endpoint_error(context, error); end
  def socket_endpoint_error?(error); end
end
class Aws::Plugins::RetryErrors < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Aws::Plugins::RetryErrors::ErrorInspector
  def checksum?; end
  def endpoint_discovery?(context); end
  def expired_credentials?; end
  def extract_name(error); end
  def initialize(error, http_status_code); end
  def networking?; end
  def refreshable_credentials?(context); end
  def retryable?(context); end
  def server?; end
  def throttling_error?; end
end
class Aws::Plugins::RetryErrors::Handler < Seahorse::Client::Handler
  def call(context); end
  def delay_retry(context); end
  def error_for(response); end
  def response_truncatable?(context); end
  def retry_if_possible(response); end
  def retry_limit(context); end
  def retry_request(context, error); end
  def should_retry?(context, error); end
end
class Aws::Plugins::GlobalConfiguration < Seahorse::Client::Plugin
  def apply_aws_defaults(client_class, options); end
  def apply_service_defaults(client_class, options); end
  def before_initialize(client_class, options); end
  def self.add_identifier(identifier); end
  def self.identifiers; end
end
class Aws::Plugins::RegionalEndpoint < Seahorse::Client::Plugin
  def after_initialize(client); end
  def self.resolve_region(cfg); end
end
class Aws::Plugins::EndpointDiscovery < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
  def self.resolve_endpoint_discovery(cfg); end
end
class Aws::Plugins::EndpointDiscovery::Handler < Seahorse::Client::Handler
  def _apply_endpoint_discovery_user_agent(ctx); end
  def _discover_endpoint(ctx, required); end
  def _valid_uri(address); end
  def call(context); end
end
class Aws::Plugins::EndpointPattern < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Aws::Plugins::EndpointPattern::Handler < Seahorse::Client::Handler
  def _apply_endpoint_trait(context, trait); end
  def _replace_label_value(ori, label, input_ref, params); end
  def call(context); end
end
class Aws::Plugins::ResponsePaging < Seahorse::Client::Plugin
end
class Aws::Plugins::ResponsePaging::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::StubResponses < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
  def after_initialize(client); end
end
class Aws::Plugins::StubResponses::Handler < Seahorse::Client::Handler
  def apply_stub(stub, response, async_mode = nil); end
  def call(context); end
  def signal_error(error, http_resp); end
  def signal_http(stub, http_resp, async_mode = nil); end
end
class Aws::Plugins::IdempotencyToken < Seahorse::Client::Plugin
end
class Aws::Plugins::IdempotencyToken::Handler < Seahorse::Client::Handler
  def auto_fill(params, ref); end
  def call(context); end
end
class Aws::Plugins::JsonvalueConverter < Seahorse::Client::Plugin
end
class Aws::Plugins::JsonvalueConverter::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::ClientMetricsPlugin < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
  def self.resolve_client_id(cfg); end
  def self.resolve_client_side_monitoring(cfg); end
  def self.resolve_client_side_monitoring_host(cfg); end
  def self.resolve_client_side_monitoring_port(cfg); end
  def self.resolve_publisher(cfg); end
end
class Aws::Plugins::ClientMetricsPlugin::Handler < Seahorse::Client::Handler
  def _calculate_service_id(context); end
  def _fallback_service_id(id); end
  def call(context); end
end
class Aws::Plugins::ClientMetricsSendPlugin < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Aws::Plugins::ClientMetricsSendPlugin::LatencyHandler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::ClientMetricsSendPlugin::AttemptHandler < Seahorse::Client::Handler
  def _extract_error_name(error); end
  def call(context); end
end
class Aws::Plugins::TransferEncoding < Seahorse::Client::Plugin
end
class Aws::Plugins::TransferEncoding::Handler < Seahorse::Client::Handler
  def call(context); end
  def requires_length?(ref); end
  def streaming?(ref); end
end
class Aws::Plugins::SignatureV4 < Seahorse::Client::Plugin
  def add_handlers(handlers, cfg); end
  def self.apply_authtype(context); end
  def self.apply_signature(options = nil); end
  def self.build_signer(cfg); end
end
class Aws::Plugins::SignatureV4::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::SignatureV4::MissingCredentialsSigner
  def sign_request(*args); end
end
module Aws::Query
end
class Aws::Query::EC2ParamBuilder
  def apply(ref, params); end
  def blob(value); end
  def format(ref, value, prefix); end
  def initialize(param_list); end
  def list(ref, values, prefix); end
  def params; end
  def query_name(ref); end
  def set(name, value); end
  def structure(ref, values, prefix); end
  def timestamp(ref, value); end
  def ucfirst(str); end
  include Seahorse::Model::Shapes
end
class Aws::Query::Handler < Seahorse::Client::Handler
  def apply_params(param_list, params, rules); end
  def build_request(context); end
  def call(context); end
  def parse_xml(context); end
  def remove_wrapper(data, context); end
  def rules(context); end
  def xml(context); end
  include Seahorse::Model::Shapes
end
class Aws::Query::Handler::WRAPPER_STRUCT < Struct
  def response_metadata; end
  def response_metadata=(_); end
  def result; end
  def result=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::Query::Handler::METADATA_STRUCT < Struct
  def request_id; end
  def request_id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::Query::Param
  def <=>(other); end
  def ==(other); end
  def escape(str); end
  def initialize(name, value = nil); end
  def name; end
  def to_s; end
  def value; end
end
class Aws::Query::ParamBuilder
  def apply(ref, params); end
  def blob(value); end
  def flat?(ref); end
  def format(ref, value, prefix); end
  def initialize(param_list); end
  def list(ref, values, prefix); end
  def map(ref, values, prefix); end
  def params; end
  def query_name(ref, default = nil); end
  def set(name, value); end
  def structure(ref, values, prefix); end
  def timestamp(ref, value); end
  include Seahorse::Model::Shapes
end
class Aws::Query::ParamList
  def [](param_name); end
  def []=(param_name, param_value = nil); end
  def delete(param_name); end
  def each(&block); end
  def empty?; end
  def initialize; end
  def set(param_name, param_value = nil); end
  def to_a; end
  def to_io; end
  def to_s; end
  include Enumerable
end
class Aws::Query::ParamList::IoWrapper
  def initialize(param_list); end
  def param_list; end
  def read(bytes = nil, output_buffer = nil); end
  def rewind; end
  def size; end
end
module Aws::Plugins::Protocols
end
class Aws::Plugins::Protocols::Query < Seahorse::Client::Plugin
end
module Aws::STS::Plugins
end
class Aws::STS::Plugins::STSRegionalEndpoints < Seahorse::Client::Plugin
  def self.resolve_sts_regional_endpoints(cfg); end
end
class Aws::STS::Client < Seahorse::Client::Base
  def assume_role(params = nil, options = nil); end
  def assume_role_with_saml(params = nil, options = nil); end
  def assume_role_with_web_identity(params = nil, options = nil); end
  def build_request(operation_name, params = nil); end
  def decode_authorization_message(params = nil, options = nil); end
  def get_access_key_info(params = nil, options = nil); end
  def get_caller_identity(params = nil, options = nil); end
  def get_federation_token(params = nil, options = nil); end
  def get_session_token(params = nil, options = nil); end
  def initialize(*args); end
  def self.errors_module; end
  def self.identifier; end
  def waiter_names; end
  include Anonymous_Module_36
  include Aws::ClientStubs
end
module Anonymous_Module_36
  def assume_role(*args, &block); end
  def assume_role_with_saml(*args, &block); end
  def assume_role_with_web_identity(*args, &block); end
  def decode_authorization_message(*args, &block); end
  def get_access_key_info(*args, &block); end
  def get_caller_identity(*args, &block); end
  def get_federation_token(*args, &block); end
  def get_session_token(*args, &block); end
end
module Aws::STS::Errors
  extend Aws::Errors::DynamicErrors
end
class Aws::STS::Errors::ServiceError < Aws::Errors::ServiceError
end
class Aws::STS::Errors::ExpiredTokenException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::IDPCommunicationErrorException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::IDPRejectedClaimException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::InvalidAuthorizationMessageException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::InvalidIdentityTokenException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::MalformedPolicyDocumentException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::PackedPolicyTooLargeException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::RegionDisabledException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Resource
  def client; end
  def initialize(options = nil); end
end
class Aws::Plugins::Protocols::JsonRpc < Seahorse::Client::Plugin
end
class Aws::Plugins::Protocols::RestXml < Seahorse::Client::Plugin
end
class Aws::Plugins::EventStreamConfiguration < Seahorse::Client::Plugin
end
module Aws::Waiters
end
module Aws::Waiters::Errors
end
class Aws::Waiters::Errors::WaiterFailed < StandardError
end
class Aws::Waiters::Errors::FailureStateError < Aws::Waiters::Errors::WaiterFailed
  def initialize(response); end
  def response; end
end
class Aws::Waiters::Errors::TooManyAttemptsError < Aws::Waiters::Errors::WaiterFailed
  def attempts; end
  def initialize(attempts); end
end
class Aws::Waiters::Errors::UnexpectedError < Aws::Waiters::Errors::WaiterFailed
  def error; end
  def initialize(error); end
end
class Aws::Waiters::Errors::NoSuchWaiterError < ArgumentError
  def initialize(waiter_name, waiter_names); end
end
class Aws::Waiters::Poller
  def acceptor_matches?(acceptor, response); end
  def call(options = nil); end
  def initialize(options = nil); end
  def matches_error?(acceptor, response); end
  def matches_path?(acceptor, response); end
  def matches_pathAll?(acceptor, response); end
  def matches_pathAny?(acceptor, response); end
  def matches_status?(acceptor, response); end
  def non_empty_array(acceptor, response, &block); end
  def operation_name; end
  def path(acceptor); end
  def send_request(options); end
end
class Aws::Waiters::Waiter
  def before_attempt(&block); end
  def before_wait(&block); end
  def delay; end
  def delay=(arg0); end
  def initialize(options = nil); end
  def interval; end
  def interval=(arg0); end
  def max_attempts; end
  def max_attempts=(arg0); end
  def poll(options); end
  def poller; end
  def trigger_before_attempt(attempts); end
  def trigger_before_wait(attempts, response); end
  def wait(options); end
end
