# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/activesupport/all/activesupport.rbi
#
# activesupport-3.2.22.5

module ActiveSupport
  def self.execute_hook(base, options, block); end
  def self.load_all!; end
  def self.load_all_hooks; end
  def self.load_all_hooks=(arg0); end
  def self.on_load(name, options = nil, &block); end
  def self.on_load_all(&hook); end
  def self.run_load_hooks(name, base = nil); end
  extend ActiveSupport::Autoload
end
module ActiveSupport::Inflector
  def apply_inflections(word, rules); end
  def camelize(term, uppercase_first_letter = nil); end
  def classify(table_name); end
  def const_regexp(camel_cased_word); end
  def constantize(camel_cased_word); end
  def dasherize(underscored_word); end
  def deconstantize(path); end
  def demodulize(path); end
  def foreign_key(class_name, separate_class_name_and_id_with_underscore = nil); end
  def humanize(lower_case_and_underscored_word); end
  def inflections; end
  def ordinalize(number); end
  def parameterize(string, sep = nil); end
  def pluralize(word); end
  def safe_constantize(camel_cased_word); end
  def singularize(word); end
  def tableize(class_name); end
  def titleize(word); end
  def transliterate(string, replacement = nil); end
  def underscore(camel_cased_word); end
  extend ActiveSupport::Inflector
  extend ActiveSupport::Inflector
end
class ActiveSupport::Inflector::Inflections
  def acronym(word); end
  def acronym_regex; end
  def acronyms; end
  def clear(scope = nil); end
  def human(rule, replacement); end
  def humans; end
  def initialize; end
  def irregular(singular, plural); end
  def plural(rule, replacement); end
  def plurals; end
  def self.instance; end
  def singular(rule, replacement); end
  def singulars; end
  def uncountable(*words); end
  def uncountables; end
end
module ActiveSupport::Autoload
  def autoload(const_name, path = nil); end
  def autoload_at(path); end
  def autoload_under(path); end
  def autoloads; end
  def eager_autoload; end
  def self.eager_autoload!; end
end
module ActiveSupport::VERSION
end
module ActiveSupport::Notifications
  def self.instrument(name, payload = nil); end
  def self.instrumenter; end
  def self.notifier; end
  def self.notifier=(arg0); end
  def self.publish(name, *args); end
  def self.subscribe(*args, &block); end
  def self.subscribed(callback, *args, &block); end
  def self.unsubscribe(args); end
end
class ActiveSupport::Notifications::Fanout
  def initialize; end
  def listeners_for(name); end
  def listening?(name); end
  def publish(name, *args); end
  def subscribe(pattern = nil, block = nil); end
  def unsubscribe(subscriber); end
  def wait; end
end
class ActiveSupport::Notifications::Fanout::Subscriber
  def initialize(pattern, delegate); end
  def matches?(subscriber_or_name); end
  def publish(message, *args); end
  def subscribed_to?(name); end
end
class Array
  def blank?; end
  def extract_options!; end
  def fifth; end
  def forty_two; end
  def fourth; end
  def from(position); end
  def in_groups(number, fill_with = nil); end
  def in_groups_of(number, fill_with = nil); end
  def second; end
  def self.try_convert(arg0); end
  def split(value = nil); end
  def third; end
  def to(position); end
  def to_default_s; end
  def to_formatted_s(format = nil); end
  def to_json(options = nil); end
  def to_param; end
  def to_query(key); end
  def to_sentence(options = nil); end
  def to_xml(options = nil); end
  def uniq_by!; end
  def uniq_by; end
end
module ActiveSupport::Deprecation
  def self.behavior; end
  def self.behavior=(behavior); end
  def self.debug; end
  def self.debug=(arg0); end
  def self.deprecate_methods(target_module, *method_names); end
  def self.deprecated_method_warning(method_name, message = nil); end
  def self.deprecation_caller_message(callstack); end
  def self.deprecation_horizon; end
  def self.deprecation_horizon=(arg0); end
  def self.deprecation_message(callstack, message = nil); end
  def self.extract_callstack(callstack); end
  def self.silence; end
  def self.silenced; end
  def self.silenced=(arg0); end
  def self.warn(message = nil, callstack = nil); end
end
class Module
  def alias_attribute(new_name, old_name); end
  def alias_method_chain(target, feature); end
  def anonymous?; end
  def attr_internal(*attrs); end
  def attr_internal_accessor(*attrs); end
  def attr_internal_define(attr_name, type); end
  def attr_internal_ivar_name(attr); end
  def attr_internal_reader(*attrs); end
  def attr_internal_writer(*attrs); end
  def delegate(*methods); end
  def deprecate(*method_names); end
  def duplicable?; end
  def instance_method_names(*args); end
  def local_constant_names; end
  def local_constants; end
  def mattr_accessor(*syms); end
  def mattr_reader(*syms); end
  def mattr_writer(*syms); end
  def method_names(*args); end
  def parent; end
  def parent_name; end
  def parents; end
  def qualified_const_defined?(path, search_parents = nil); end
  def qualified_const_get(path); end
  def qualified_const_set(path, value); end
  def reachable?; end
  def redefine_method(method, &block); end
  def remove_possible_method(method); end
  def self.attr_internal_naming_format; end
  def self.attr_internal_naming_format=(arg0); end
  def synchronize(*args, &block); end
  def synchronize_with_deprecation(*args, &block); end
  def synchronize_without_deprecation(*methods); end
end
class Hash
  def assert_valid_keys(*valid_keys); end
  def blank?; end
  def deep_dup; end
  def deep_merge!(other_hash); end
  def deep_merge(other_hash); end
  def diff(h2); end
  def except!(*keys); end
  def except(*keys); end
  def extract!(*keys); end
  def extractable_options?; end
  def nested_under_indifferent_access; end
  def reverse_merge!(other_hash); end
  def reverse_merge(other_hash); end
  def reverse_update(other_hash); end
  def self.[](*arg0); end
  def self.from_trusted_xml(xml); end
  def self.from_xml(xml, disallowed_types = nil); end
  def self.try_convert(arg0); end
  def slice!(*keys); end
  def stringify_keys!; end
  def stringify_keys; end
  def symbolize_keys!; end
  def symbolize_keys; end
  def to_json(options = nil); end
  def to_options!; end
  def to_options; end
  def to_param(namespace = nil); end
  def to_query(namespace = nil); end
  def to_xml(options = nil); end
  def with_indifferent_access; end
end
class ActiveSupport::Deprecation::DeprecationProxy
  def inspect; end
  def method_missing(called, *args, &block); end
  def self.new(*args, &block); end
end
class ActiveSupport::Deprecation::DeprecatedObjectProxy < ActiveSupport::Deprecation::DeprecationProxy
  def initialize(object, message); end
  def target; end
  def warn(callstack, called, args); end
end
class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy < ActiveSupport::Deprecation::DeprecationProxy
  def initialize(instance, method, var = nil); end
  def target; end
  def warn(callstack, called, args); end
end
class ActiveSupport::Deprecation::DeprecatedConstantProxy < ActiveSupport::Deprecation::DeprecationProxy
  def class; end
  def initialize(old_const, new_const); end
  def target; end
  def warn(callstack, called, args); end
end
module ActiveSupport::Concern
  def append_features(base); end
  def included(base = nil, &block); end
  def self.extended(base); end
end
module ActiveSupport::Base64
  def self.decode64(value); end
  def self.encode64(value); end
  def self.encode64s(value); end
end
module ActiveSupport::Multibyte
  def self.clean(string); end
  def self.proxy_class; end
  def self.proxy_class=(klass); end
  def self.valid_character; end
  def self.verify!(string); end
  def self.verify(string); end
end
class String
  def acts_like_string?; end
  def at(position); end
  def blank?; end
  def camelcase(first_letter = nil); end
  def camelize(first_letter = nil); end
  def classify; end
  def constantize; end
  def dasherize; end
  def deconstantize; end
  def demodulize; end
  def encoding_aware?; end
  def ends_with?(*arg0); end
  def exclude?(string); end
  def first(limit = nil); end
  def foreign_key(separate_class_name_and_id_with_underscore = nil); end
  def from(position); end
  def html_safe; end
  def humanize; end
  def inquiry; end
  def is_utf8?; end
  def last(limit = nil); end
  def mb_chars; end
  def parameterize(sep = nil); end
  def pluralize(count = nil); end
  def safe_constantize; end
  def singularize; end
  def squish!; end
  def squish; end
  def starts_with?(*arg0); end
  def strip_heredoc; end
  def tableize; end
  def titlecase; end
  def titleize; end
  def to(position); end
  def to_date; end
  def to_datetime; end
  def to_json(options = nil); end
  def to_time(form = nil); end
  def truncate(length, options = nil); end
  def underscore; end
end
module Kernel
  def breakpoint; end
  def capture(stream); end
  def class_eval(*args, &block); end
  def debugger; end
  def enable_warnings; end
  def quietly; end
  def silence(stream); end
  def silence_stderr; end
  def silence_stream(stream); end
  def silence_warnings; end
  def suppress(*exception_classes); end
  def with_warnings(flag); end
end
class Object < BasicObject
  def `(command); end
  def acts_like?(duck); end
  def blank?; end
  def duplicable?; end
  def html_safe?; end
  def in?(*args); end
  def instance_values; end
  def instance_variable_names; end
  def presence; end
  def present?; end
  def to_json(options = nil); end
  def to_param; end
  def to_query(key); end
  def try(*a, &b); end
  def with_options(options); end
end
class NilClass
  def blank?; end
  def duplicable?; end
  def to_json(options = nil); end
  def to_param; end
  def try(*args); end
end
class FalseClass
  def blank?; end
  def duplicable?; end
  def to_json(options = nil); end
  def to_param; end
end
class TrueClass
  def blank?; end
  def duplicable?; end
  def to_json(options = nil); end
  def to_param; end
end
class Numeric
  def ago(time = nil); end
  def blank?; end
  def byte; end
  def bytes; end
  def day; end
  def days; end
  def duplicable?; end
  def exabyte; end
  def exabytes; end
  def fortnight; end
  def fortnights; end
  def from_now(time = nil); end
  def gigabyte; end
  def gigabytes; end
  def hour; end
  def hours; end
  def html_safe?; end
  def kilobyte; end
  def kilobytes; end
  def megabyte; end
  def megabytes; end
  def minute; end
  def minutes; end
  def petabyte; end
  def petabytes; end
  def second; end
  def seconds; end
  def since(time = nil); end
  def terabyte; end
  def terabytes; end
  def until(time = nil); end
  def week; end
  def weeks; end
end
module ActiveSupport::XmlMini_REXML
  def collapse(element, depth); end
  def empty_content?(element); end
  def get_attributes(element); end
  def merge!(hash, key, value); end
  def merge_element!(hash, element, depth); end
  def merge_texts!(hash, element); end
  def parse(data); end
  extend ActiveSupport::XmlMini_REXML
end
module ActiveSupport::XmlMini
  def _dasherize(key); end
  def _parse_binary(bin, entity); end
  def _parse_file(file, entity); end
  def backend; end
  def backend=(name); end
  def depth; end
  def depth=(arg0); end
  def parse(*args, &block); end
  def rename_key(key, options = nil); end
  def to_tag(key, value, options); end
  def with_backend(name); end
  extend ActiveSupport::XmlMini
end
module ActiveSupport::XmlMini::FileLike
  def content_type; end
  def content_type=(arg0); end
  def original_filename; end
  def original_filename=(arg0); end
end
module Benchmark
  def self.ms; end
end
class BigDecimal < Numeric
  def _original_to_s(*arg0); end
  def duplicable?; end
  def encode_with(coder); end
  def to_d; end
  def to_formatted_s(format = nil); end
  def to_yaml(opts = nil); end
end
class Class < Module
  def _stash_object_in_method(object, method, instance_reader = nil); end
  def _superclass_delegating_accessor(name, options = nil); end
  def cattr_accessor(*syms, &blk); end
  def cattr_reader(*syms); end
  def cattr_writer(*syms); end
  def class_attribute(*attrs); end
  def descendants; end
  def duplicable?; end
  def subclasses; end
  def superclass_delegating_accessor(name, options = nil); end
end
class ActiveSupport::OrderedHash < Hash
  def encode_with(coder); end
  def extractable_options?; end
  def nested_under_indifferent_access; end
  def to_yaml(opts = nil); end
  def to_yaml_type; end
end
module Enumerable
  def exclude?(object); end
  def index_by; end
  def many?; end
end
class Range
  def include_with_range?(value); end
  def include_without_range?(arg0); end
  def overlaps?(other); end
  def step_with_blockless(*args, &block); end
  def step_without_blockless(*arg0); end
  def sum(identity = nil); end
  def to_default_s; end
  def to_formatted_s(format = nil); end
end
class File < IO
  def self.empty?(arg0); end
end
class Time
  def acts_like_time?; end
  def advance(options); end
  def ago(seconds); end
  def all_day; end
  def all_month; end
  def all_quarter; end
  def all_week(start_day = nil); end
  def all_year; end
  def at_beginning_of_day; end
  def at_beginning_of_hour; end
  def at_beginning_of_month; end
  def at_beginning_of_quarter; end
  def at_beginning_of_week(start_day = nil); end
  def at_beginning_of_year; end
  def at_end_of_month; end
  def at_end_of_quarter; end
  def at_end_of_week(start_day = nil); end
  def at_end_of_year; end
  def at_midnight; end
  def beginning_of_day; end
  def beginning_of_hour; end
  def beginning_of_month; end
  def beginning_of_quarter; end
  def beginning_of_week(start_day = nil); end
  def beginning_of_year; end
  def change(options); end
  def compare_with_coercion(other); end
  def compare_without_coercion(arg0); end
  def days_to_week_start(start_day = nil); end
  def end_of_day; end
  def end_of_hour; end
  def end_of_month; end
  def end_of_quarter; end
  def end_of_week(start_day = nil); end
  def end_of_year; end
  def eql_with_coercion(other); end
  def eql_without_coercion(arg0); end
  def formatted_offset(colon = nil, alternate_utc_string = nil); end
  def future?; end
  def in(seconds); end
  def in_time_zone(zone = nil); end
  def midnight; end
  def minus_with_coercion(other); end
  def minus_with_duration(other); end
  def minus_without_coercion(other); end
  def minus_without_duration(arg0); end
  def monday; end
  def months_ago(months); end
  def months_since(months); end
  def next_month; end
  def next_week(day = nil); end
  def next_year; end
  def past?; end
  def plus_with_duration(other); end
  def plus_without_duration(arg0); end
  def prev_month; end
  def prev_week(day = nil); end
  def prev_year; end
  def seconds_since_midnight; end
  def self.===(other); end
  def self.at_with_coercion(*args); end
  def self.at_without_coercion(*arg0); end
  def self.current; end
  def self.days_in_month(month, year = nil); end
  def self.find_zone!(time_zone); end
  def self.find_zone(time_zone); end
  def self.local_time(*args); end
  def self.time_with_datetime_fallback(utc_or_local, year, month = nil, day = nil, hour = nil, min = nil, sec = nil, usec = nil); end
  def self.use_zone(time_zone); end
  def self.utc_time(*args); end
  def self.zone; end
  def self.zone=(time_zone); end
  def self.zone_default; end
  def self.zone_default=(arg0); end
  def since(seconds); end
  def sunday; end
  def to_default_s; end
  def to_formatted_s(format = nil); end
  def today?; end
  def tomorrow; end
  def weeks_ago(weeks); end
  def years_ago(years); end
  def years_since(years); end
  def yesterday; end
end
class ActiveSupport::BasicObject < BasicObject
  def raise(*args); end
end
class ActiveSupport::Duration < ActiveSupport::BasicObject
  def +(other); end
  def -(other); end
  def -@; end
  def ==(other); end
  def ago(time = nil); end
  def as_json(options = nil); end
  def duplicable?(*args, &block); end
  def from_now(time = nil); end
  def initialize(value, parts); end
  def inspect; end
  def is_a?(klass); end
  def kind_of?(klass); end
  def method_missing(method, *args, &block); end
  def parts; end
  def parts=(arg0); end
  def self.===(other); end
  def since(time = nil); end
  def sum(sign, time = nil); end
  def until(time = nil); end
  def value; end
  def value=(arg0); end
end
class ActiveSupport::TimeZone
  def <=>(zone); end
  def =~(re); end
  def at(secs); end
  def formatted_offset(colon = nil, alternate_utc_string = nil); end
  def initialize(name, utc_offset = nil, tzinfo = nil); end
  def local(*args); end
  def local_to_utc(time, dst = nil); end
  def name; end
  def now; end
  def parse(str, now = nil); end
  def period_for_local(time, dst = nil); end
  def period_for_utc(time); end
  def self.[](arg); end
  def self.all; end
  def self.create(*arg0); end
  def self.find_tzinfo(name); end
  def self.lazy_zones_map; end
  def self.lookup(name); end
  def self.new(name); end
  def self.require_tzinfo; end
  def self.seconds_to_utc_offset(seconds, colon = nil); end
  def self.us_zones; end
  def self.zones_map; end
  def to_s; end
  def today; end
  def tzinfo; end
  def utc_offset; end
  def utc_to_local(time); end
  include Comparable
end
class ActiveSupport::TimeWithZone
  def +(other); end
  def -(other); end
  def <=>(other); end
  def acts_like_time?; end
  def advance(options); end
  def ago(other); end
  def as_json(options = nil); end
  def between?(min, max); end
  def comparable_time; end
  def day; end
  def dst?; end
  def duration_of_variable_length?(obj); end
  def encode_with(coder); end
  def eql?(other); end
  def formatted_offset(colon = nil, alternate_utc_string = nil); end
  def freeze; end
  def future?; end
  def get_period_and_ensure_valid_local_time; end
  def getgm; end
  def getlocal; end
  def getutc; end
  def gmt?; end
  def gmt_offset; end
  def gmtime; end
  def gmtoff; end
  def hash; end
  def hour; end
  def httpdate; end
  def in_time_zone(new_zone = nil); end
  def initialize(utc_time, time_zone, local_time = nil, period = nil); end
  def inspect; end
  def is_a?(klass); end
  def isdst; end
  def iso8601(fraction_digits = nil); end
  def kind_of?(klass); end
  def localtime; end
  def marshal_dump; end
  def marshal_load(variables); end
  def mday; end
  def method_missing(sym, *args, &block); end
  def min; end
  def mon; end
  def month; end
  def past?; end
  def period; end
  def respond_to?(sym, include_priv = nil); end
  def rfc2822; end
  def rfc822; end
  def sec; end
  def self.name; end
  def since(other); end
  def strftime(format); end
  def time; end
  def time_zone; end
  def to_a; end
  def to_date; end
  def to_datetime; end
  def to_f; end
  def to_formatted_s(format = nil); end
  def to_i; end
  def to_s(format = nil); end
  def to_time; end
  def to_yaml(options = nil); end
  def today?; end
  def transfer_time_values_to_utc_constructor(time); end
  def tv_sec; end
  def usec; end
  def utc; end
  def utc?; end
  def utc_offset; end
  def wday; end
  def wrap_with_time_zone(time); end
  def xmlschema(fraction_digits = nil); end
  def yday; end
  def year; end
  def zone; end
  include Comparable
end
class Date
  def acts_like_date?; end
  def advance(options); end
  def ago(seconds); end
  def at_beginning_of_day; end
  def at_beginning_of_month; end
  def at_beginning_of_quarter; end
  def at_beginning_of_week(start_day = nil); end
  def at_beginning_of_year; end
  def at_end_of_month; end
  def at_end_of_quarter; end
  def at_end_of_week(start_day = nil); end
  def at_end_of_year; end
  def at_midnight; end
  def beginning_of_day; end
  def beginning_of_month; end
  def beginning_of_quarter; end
  def beginning_of_week(start_day = nil); end
  def beginning_of_year; end
  def change(options); end
  def days_to_week_start(start_day = nil); end
  def default_inspect; end
  def end_of_day; end
  def end_of_month; end
  def end_of_quarter; end
  def end_of_week(start_day = nil); end
  def end_of_year; end
  def future?; end
  def in(seconds); end
  def midnight; end
  def minus_with_duration(other); end
  def minus_without_duration(arg0); end
  def monday; end
  def months_ago(months); end
  def months_since(months); end
  def next_week(day = nil); end
  def past?; end
  def plus_with_duration(other); end
  def plus_without_duration(arg0); end
  def prev_week(day = nil); end
  def readable_inspect; end
  def self.current; end
  def self.tomorrow; end
  def self.yesterday; end
  def since(seconds); end
  def sunday; end
  def to_default_s; end
  def to_formatted_s(format = nil); end
  def to_time_in_current_zone; end
  def today?; end
  def tomorrow; end
  def weeks_ago(weeks); end
  def years_ago(years); end
  def years_since(years); end
  def yesterday; end
end
class DateTime < Date
  def <=>(other); end
  def acts_like_date?; end
  def acts_like_time?; end
  def advance(options); end
  def ago(seconds); end
  def at_beginning_of_day; end
  def at_beginning_of_hour; end
  def at_midnight; end
  def beginning_of_day; end
  def beginning_of_hour; end
  def change(options); end
  def default_inspect; end
  def end_of_day; end
  def end_of_hour; end
  def formatted_offset(colon = nil, alternate_utc_string = nil); end
  def future?; end
  def getutc; end
  def in(seconds); end
  def in_time_zone(zone = nil); end
  def inspect; end
  def midnight; end
  def past?; end
  def readable_inspect; end
  def seconds_since_midnight; end
  def seconds_since_unix_epoch; end
  def self.civil_from_format(utc_or_local, year, month = nil, day = nil, hour = nil, min = nil, sec = nil); end
  def self.current; end
  def self.local_offset; end
  def since(seconds); end
  def to_default_s; end
  def to_f; end
  def to_formatted_s(format = nil); end
  def to_i; end
  def utc; end
  def utc?; end
  def utc_offset; end
end
class Integer < Numeric
  def month; end
  def months; end
  def multiple_of?(number); end
  def ordinalize; end
  def to_json(options = nil); end
  def year; end
  def years; end
end
class Hash::DisallowedType < StandardError
  def initialize(type); end
end
class ActiveSupport::HashWithIndifferentAccess < Hash
  def []=(key, value); end
  def convert_key(key); end
  def convert_value(value); end
  def default(key = nil); end
  def delete(key); end
  def dup; end
  def extractable_options?; end
  def fetch(key, *extras); end
  def has_key?(key); end
  def include?(key); end
  def initialize(constructor = nil); end
  def key?(key); end
  def member?(key); end
  def merge!(other_hash); end
  def merge(hash); end
  def nested_under_indifferent_access; end
  def regular_update(*arg0); end
  def regular_writer(arg0, arg1); end
  def reverse_merge!(other_hash); end
  def reverse_merge(other_hash); end
  def self.new_from_hash_copying_default(hash); end
  def store(key, value); end
  def stringify_keys!; end
  def stringify_keys; end
  def symbolize_keys; end
  def to_hash; end
  def to_options!; end
  def update(other_hash); end
  def values_at(*indices); end
  def with_indifferent_access; end
end
class LoadError < ScriptError
  def is_missing?(location); end
end
class Logger
  def around_debug(before_message, after_message); end
  def around_error(before_message, after_message); end
  def around_fatal(before_message, after_message); end
  def around_info(before_message, after_message); end
  def old_datetime_format; end
  def old_datetime_format=(datetime_format); end
  def old_initialize(logdev, shift_age = nil, shift_size = nil, level: nil, progname: nil, formatter: nil, datetime_format: nil, shift_period_suffix: nil); end
  def self.define_around_helper(level); end
  def self.silencer; end
  def self.silencer=(obj); end
  def silence(*args, &block); end
  def silence_with_deprecation(*args, &block); end
  def silence_without_deprecation(temporary_level = nil); end
  def silencer; end
  def silencer=(obj); end
end
class Logger::SimpleFormatter < Logger::Formatter
  def call(severity, timestamp, progname, msg); end
end
module QualifiedConstUtils
  def self.names(path); end
  def self.raise_if_absolute(path); end
end
class NameError < StandardError
  def missing_name; end
  def missing_name?(name); end
end
class Symbol
  def duplicable?; end
end
class Float < Numeric
  def to_json(options = nil); end
end
class ActiveSupport::OptionMerger
  def initialize(context, options); end
  def method_missing(method, *arguments, &block); end
end
class Proc
  def bind(object); end
end
module Process
end
class Regexp
  def multiline?; end
end
class ERB
end
module ERB::Util
  def j(s); end
  def json_escape(s); end
  def self.j(s); end
  def self.json_escape(s); end
end
class ActiveSupport::SafeBuffer < String
  def +(other); end
  def <<(value); end
  def [](*args); end
  def capitalize!(*args); end
  def capitalize(*args, &block); end
  def chomp!(*args); end
  def chomp(*args, &block); end
  def chop!(*args); end
  def chop(*args, &block); end
  def clone_empty; end
  def concat(value); end
  def delete!(*args); end
  def delete(*args, &block); end
  def downcase!(*args); end
  def downcase(*args, &block); end
  def encode_with(coder); end
  def gsub!(*args); end
  def gsub(*args, &block); end
  def html_safe?; end
  def initialize(*arg0); end
  def initialize_copy(other); end
  def lstrip!(*args); end
  def lstrip(*args, &block); end
  def next!(*args); end
  def next(*args, &block); end
  def original_concat(*arg0); end
  def prepend!(*args); end
  def prepend(*args, &block); end
  def reverse!(*args); end
  def reverse(*args, &block); end
  def rstrip!(*args); end
  def rstrip(*args, &block); end
  def safe_concat(value); end
  def slice!(*args); end
  def slice(*args, &block); end
  def squeeze!(*args); end
  def squeeze(*args, &block); end
  def strip!(*args); end
  def strip(*args, &block); end
  def sub!(*args); end
  def sub(*args, &block); end
  def succ!(*args); end
  def succ(*args, &block); end
  def swapcase!(*args); end
  def swapcase(*args, &block); end
  def to_param; end
  def to_s; end
  def to_yaml(*args); end
  def tr!(*args); end
  def tr(*args, &block); end
  def tr_s!(*args); end
  def tr_s(*args, &block); end
  def upcase!(*args); end
  def upcase(*args, &block); end
end
class ActiveSupport::SafeBuffer::SafeConcatError < StandardError
  def initialize; end
end
class ActiveSupport::StringInquirer < String
  def method_missing(method_name, *arguments); end
end
module URI
  def self.parser; end
end
